{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Start","text":""},{"location":"#dict2graph","title":"Dict2graph","text":"<p>Transfer (json compatible) Python dicts into a Neo4j graph database. dict2graph also comes with some powerful data transform capabilities.</p> <p>Maintainer: tim.bleimehl@dzd-ev.de</p> <p>Licence: MIT</p> <p>public issue tracker: https://github.com/dzd-ev/dict2graph-docs/issues</p> <p>user docs: https://dzd-ev.github.io/dict2graph-docs/</p> <p>source code: https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph</p> <p>important upstream modules:</p> <ul> <li>https://github.com/kaiserpreusse/graphio </li> <li>https://github.com/neo4j/neo4j-python-driver </li> <li>https://github.com/py2neo-org/py2neo </li> </ul> <p>Content:</p> <ul> <li>Dict2graph</li> <li>Install</li> <li>What is dict2graph</li> <li>Recommended workflow</li> <li>What dict2graph is not</li> <li>py2neo depcrecation warning</li> <li>Basic Usage Example</li> <li>Load a dict<ul> <li>Transform the model</li> </ul> </li> </ul>"},{"location":"#install","title":"Install","text":"<p>at the moment if dev:</p> <p><code>pip3 install git+https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph.git@V3</code></p> <p>Later will be:</p> <p><code>pip3 install dict2graph</code></p>"},{"location":"#what-is-dict2graph","title":"What is dict2graph","text":"<p>With dict2graph you can transfer python dicts into a neo4j graph out of the box. And if you are not happy with the structure of the result, dict2graph comes with a bunch of, transformation tools, which are easy to apply to your model.</p>"},{"location":"#recommended-workflow","title":"Recommended workflow","text":"<p>The recommended workflow is:</p> <ul> <li>Load your dict (or a sample of your larger datasets) as it is, with dict2graph into a neo4j test instance</li> <li>Inspect the result in neo4j</li> <li>Add dict2graph-transformators to shape your resulting graph model</li> <li>Wipe your neo4j test instance</li> <li>Repeat the work flow with the changed dict2graph-transformators until your happy with the result</li> </ul>"},{"location":"#what-dict2graph-is-not","title":"What dict2graph is not","text":"<p>dict2graph can not be used for de-/serializing your dict into a graph database. There is no <code>graph2dict</code> functionality (nore is it planned to have one). Your data/dict will be transformed to be more suitable in a graph represantation. On the way, certain informations can be lost. Reproducing the exact same dict from the graph is not possible in many cases.</p>"},{"location":"#py2neo-depcrecation-warning","title":"py2neo depcrecation warning","text":"<p>In past versions of <code>dict2graph</code>, the awesome <code>py2neo</code> library was the only way to connect to a Neo4j instance. But (sadly) this lib is in a low-maintanance mode. For now it is still supported but marked as deprecated. We recommend to switch to the official Neo4j Python Driver. </p>"},{"location":"#basic-usage-example","title":"Basic Usage Example","text":"<p>With formalities out of the way, lets have some simple examples how dict2graph works...</p>"},{"location":"#load-a-dict","title":"Load a dict","text":"<pre><code>from dict2graph import Dict2graph\nfrom neo4j import GraphDatabase\n# connect to our neo4j database\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n# lets create a small random  dict\ndic = {\n\"Action\": {\n\"id\": 1,\n\"target\": \"El Oued\",\n\"Entities\": [{\"id\": \"Isabelle Eberhardt\"}, {\"id\": \"Slim\u00e8ne Ehnni\"}],\n}\n}\n# create a dict2graph instance, \n# parse the dict \n# and load it into our neo4j instance.\nDict2graph().parse(dic).create(NEO4J_DRIVER)\n</code></pre> <p>This will result in following graph:</p> <p></p>"},{"location":"#transform-the-model","title":"Transform the model","text":"<p>We now have loaded the dict data into a Neo4j Graph. But usally we dont need stuff like explicit <code>list</code>s in a graph. Also it is common to uppercase relationship types and capitalize labels.</p> <p>So we need to make some adjustments to improve the graph represenation of the dict. This is where <code>dict2graph.Transformer</code>s come into play.</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans, RelTrans\nfrom py2neo import Graph\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata = {\n\"Action\": {\n\"id\": 1,\n\"target\": \"El Oued\",\n\"Entities\": [{\"id\": \"Isabelle Eberhardt\"}, {\"id\": \"Slim\u00e8ne Ehnni\"}],\n}\n}\nd2g = Dict2graph()\nd2g.add_transformation(\n[\nTransformer.match_node().do(NodeTrans.CapitalizeLabels()),\nTransformer.match_rel().do(RelTrans.UppercaseRelationType()),\nTransformer.match_node().do(NodeTrans.PopListHubNodes()),\n]\n)\nd2g.parse(data)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>Now that looks more like a graph we are used to, isn't it?</p> <p></p> <p>There are a lot of more powerful <code>Transformator</code>s and you can even make your own \ud83d\ude80!  Have a deeper look into the docs to learn more how Transformators work.</p>"},{"location":"DOCS_README/","title":"dict2graph Docs Pages Repo","text":"<p>Maintainer: tim.bleimehl at dzd-ev.de</p> <p>this is the repository for the dict2graph documentation website/github pages.</p> <p>dict2graph is a Python tool to transfer json data into a Neo4j graph</p> <p>Visit https://dzd-ev.github.io/dict2graph-docs/ to learn more about dict2graph. Or visit https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph to browse the dict2graph source code.</p>"},{"location":"basics/","title":"Basic concepts of dict2graph","text":""},{"location":"basics/#creating","title":"Creating","text":"<p>To get a grasp how dict2graph is working lets have a look at a simple example</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans, RelTrans\nfrom neo4j import GraphDatabase, Driver\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"affiliation\": {\"name\": \"Du\u00e1l\u00e1\"},\n}\n}\nd2g = Dict2graph()\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>This will create a graph that looks like</p> <p></p> <p>You can see dict2graph interpreted the dict key <code>person</code> as the name (or better \"label\") of the object, which is behind the key. Same for <code>affiliation</code>. </p>"},{"location":"basics/#when-creating-is-not-enough","title":"When creating is not enough","text":"<p>Lets have example with two datasets.</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans, RelTrans\nfrom neo4j import GraphDatabase, Driver\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata_1 = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"affiliation\": {\"name\": \"Du\u00e1l\u00e1\"},\n}\n}\ndata_2 = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"mission\": {\"name\": \"resistance leader\"},\n}\n}\nd2g = Dict2graph()\nd2g.parse(data_1)\nd2g.parse(data_2)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>This results in a pretty unintuitiv graph:</p> <p></p> <p>We would expect two node pairs, each with one relationship. Something like:</p> <p></p> <p>But what we get is are 4 relationships. Why is that?  </p> <p>dict2graph creates relationship targets (start node, end node) based on the target nodes labels and properties. So if we have a node that looks equal to another they both will end up as a relatioship target, even we only wanted to relate one of them.</p> <p>You can workaround that by creating a custom key property. More on that later in the Chapter <code>dict2graph.Transformers</code>.</p>"},{"location":"basics/#merging","title":"Merging","text":"<p>In our case it would make sense to just merge equal nodes. We can be pretty sure, in our dataset, that <code>Rudolf</code> from dataset 1 is the same as <code>Rudolf</code> from dataset 2.</p> <p>So lets do that:</p> <p><pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans, RelTrans\nfrom neo4j import GraphDatabase, Driver\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata_1 = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"affiliation\": {\"name\": \"Du\u00e1l\u00e1\"},\n}\n}\ndata_2 = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"mission\": {\"name\": \"resistance leader\"},\n}\n}\nd2g = Dict2graph()\nd2g.parse(data_1)\nd2g.parse(data_2)\nd2g.merge(NEO4J_DRIVER)\n</code></pre> </p> <p>That looks neat, doesn't it? We merged our two dataset in one graph and connected the informations. That what graphs are for in the first place \ud83d\ude80</p>"},{"location":"list_generic_transformer/","title":"Generic Transformers","text":"<p>dict2graph comes with a lot of predefined transformators. For a basic concepts of a dict2Graph transformators have a look at How to use Transformators</p>"},{"location":"list_generic_transformer/#generic-transformators-list","title":"Generic Transformators List","text":"<p>This is a list if transformators that can be applied to nodes and relationships</p>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.AddProperty","title":"<code>AddProperty</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code>, <code>_NodeTransformerBase</code></p> <p>Add a property to a node Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_node(\"person\").do(NodeTrans.AddProperty({\"my_new_prop_key\":\"my_new_prop_value_1111\"}))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{name:'Camina',my_new_prop_key:\"my_new_prop_value_1111\"})</code>.</p> Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>class AddProperty(_RelationTransformerBase, _NodeTransformerBase):\n\"\"\"Add a property to a node\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_node(\"person\").do(NodeTrans.AddProperty({\"my_new_prop_key\":\"my_new_prop_value_1111\"}))\n        )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{name:'Camina',my_new_prop_key:\"my_new_prop_value_1111\"})`.\n    \"\"\"\ndef __init__(self, properties: Dict):\n\"\"\"_summary_\n        Args:\n            properties (Union[str, List[str]]): A property key or a list of property keys as strings that should be removed\n        \"\"\"\nif isinstance(properties, str):\nproperties = [properties]\nself.properties = properties\ndef transform_node(self, node: Node):\nself._transform(node)\ndef transform_rel(self, rel: Relation):\nself._transform(rel)\ndef _transform(self, obj: Union[Node, Relation]):\nobj.update(self.properties)\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.AddProperty.__init__","title":"<code>__init__(properties)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>Union[str, List[str]]</code> <p>A property key or a list of property keys as strings that should be removed</p> required Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>def __init__(self, properties: Dict):\n\"\"\"_summary_\n    Args:\n        properties (Union[str, List[str]]): A property key or a list of property keys as strings that should be removed\n    \"\"\"\nif isinstance(properties, str):\nproperties = [properties]\nself.properties = properties\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.OverridePropertyName","title":"<code>OverridePropertyName</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code>, <code>_NodeTransformerBase</code></p> <p>Replace a property name/key with a new string of your choice. Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina Drummer\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_node(\"person\").do(NodeTrans.OverridePropertyName(\"name\",\"fullname\"))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{fullname:'Camina Drummer'})</code></p> Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>class OverridePropertyName(_RelationTransformerBase, _NodeTransformerBase):\n\"\"\"Replace a property name/key with a new string of your choice.\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina Drummer\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_node(\"person\").do(NodeTrans.OverridePropertyName(\"name\",\"fullname\"))\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{fullname:'Camina Drummer'})`\n    \"\"\"\ndef __init__(self, source_property_name: str, target_property_name: str):\n\"\"\"\n        Args:\n            source_property_name (str): The property key you want to be replaced.\n            target_property_name (str): The The new name of the property.\n        \"\"\"\nself.source_property_name = source_property_name\nself.target_property_name = target_property_name\ndef _transform(self, obj: Dict):\nif self.source_property_name in obj:\nobj[self.target_property_name] = obj.pop(self.source_property_name)\ndef transform_node(self, node: Node):\nself._transform(node)\ndef transform_rel(self, rel: Relation):\nself._transform(rel)\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.OverridePropertyName.__init__","title":"<code>__init__(source_property_name, target_property_name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_property_name</code> <code>str</code> <p>The property key you want to be replaced.</p> required <code>target_property_name</code> <code>str</code> <p>The The new name of the property.</p> required Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>def __init__(self, source_property_name: str, target_property_name: str):\n\"\"\"\n    Args:\n        source_property_name (str): The property key you want to be replaced.\n        target_property_name (str): The The new name of the property.\n    \"\"\"\nself.source_property_name = source_property_name\nself.target_property_name = target_property_name\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.RemoveProperty","title":"<code>RemoveProperty</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code>, <code>_NodeTransformerBase</code></p> <p>Remove a property from a node Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina\", \"id\":\"sdf343\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_node(\"person\").do(NodeTrans.RemoveProperty(id))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{name:'Camina'})</code>. the <code>id</code> property will be thrown away.</p> Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>class RemoveProperty(_RelationTransformerBase, _NodeTransformerBase):\n\"\"\"Remove a property from a node\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina\", \"id\":\"sdf343\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_node(\"person\").do(NodeTrans.RemoveProperty(id))\n        )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{name:'Camina'})`. the `id` property will be thrown away.\n    \"\"\"\ndef __init__(self, property_keys: Union[str, List[str]]):\n\"\"\"_summary_\n        Args:\n            properties (Union[str, List[str]]): A property key or a list of property keys as strings that should be removed\n        \"\"\"\nif isinstance(property_keys, str):\nproperty_keys = [property_keys]\nself.property_keys = property_keys\ndef custom_node_match(self, node: Node) -&gt; bool:\n# check if node keys and defined properties have an overlap\nreturn not set(self.property_keys).isdisjoint(set(node.keys()))\ndef transform_node(self, node: Node):\nself._transform(node)\ndef transform_rel(self, rel: Relation):\nself._transform(rel)\ndef _transform(self, obj: Union[Node, Relation]):\nfor prop in self.property_keys:\nobj.pop(prop, None)\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.RemoveProperty.__init__","title":"<code>__init__(property_keys)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>Union[str, List[str]]</code> <p>A property key or a list of property keys as strings that should be removed</p> required Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>def __init__(self, property_keys: Union[str, List[str]]):\n\"\"\"_summary_\n    Args:\n        properties (Union[str, List[str]]): A property key or a list of property keys as strings that should be removed\n    \"\"\"\nif isinstance(property_keys, str):\nproperty_keys = [property_keys]\nself.property_keys = property_keys\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.TypeCastProperty","title":"<code>TypeCastProperty</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code>, <code>_NodeTransformerBase</code></p> <p>change the type of property values. Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina\", \"captain\":\"true\", \"age\":\"39\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation([\nTransformer.match_node(\"person\").do(NodeTrans.TypeCastProperty(\"captain\",bool)),\nTransformer.match_node(\"person\").do(NodeTrans.TypeCastProperty(\"age\",int)),\n])\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{name:'Camina',captain:true,age:27})</code></p> Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>class TypeCastProperty(_RelationTransformerBase, _NodeTransformerBase):\n\"\"\"change the type of property values.\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina\", \"captain\":\"true\", \"age\":\"39\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation([\n        Transformer.match_node(\"person\").do(NodeTrans.TypeCastProperty(\"captain\",bool)),\n        Transformer.match_node(\"person\").do(NodeTrans.TypeCastProperty(\"age\",int)),\n    ])\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{name:'Camina',captain:true,age:27})`\n    \"\"\"\ndef __init__(self, property_name: str, target_type: Union[str, int, float, bool]):\n\"\"\"\n        Args:\n            property_name (str): The property key that should be changed\n            target_type (Union[str, int, float, bool]): The type that should result\n        \"\"\"\nself.property_name = property_name\nself.target_type = target_type\ndef _transform(self, obj: Dict):\nif self.property_name in obj:\nif self.target_type == bool:\nobj[self.property_name] = True\nif obj[self.property_name] in [\n0,\n\"0\",\nNone,\n\"Null\",\n\"false\",\n\"False\",\n\"f\",\n\"F\",\n\"No\",\n\"no\",\n]:\nobj[self.property_name] = False\nelse:\nobj[self.property_name] = self.target_type(obj[self.property_name])\ndef transform_node(self, node: Node):\nself._transform(node)\ndef transform_rel(self, rel: Relation):\nself._transform(rel)\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.TypeCastProperty.__init__","title":"<code>__init__(property_name, target_type)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>property_name</code> <code>str</code> <p>The property key that should be changed</p> required <code>target_type</code> <code>Union[str, int, float, bool]</code> <p>The type that should result</p> required Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>def __init__(self, property_name: str, target_type: Union[str, int, float, bool]):\n\"\"\"\n    Args:\n        property_name (str): The property key that should be changed\n        target_type (Union[str, int, float, bool]): The type that should result\n    \"\"\"\nself.property_name = property_name\nself.target_type = target_type\n</code></pre>"},{"location":"list_node_transformer/","title":"Node Transformers","text":"<p>dict2graph comes with a lot of predefined transformators. For a basic concepts of a dict2Graph transformators have a look at How to use Transformators</p>"},{"location":"list_node_transformer/#node-transformators-list","title":"Node Transformators List","text":"<p>This is a list if transformators that can be applied to nodes only</p>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.AddLabel","title":"<code>AddLabel</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Add one or more new labels to nodes Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina Drummer\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_node(\"person\").do(NodeTrans.AddLabel(\"Character\"))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre></p> <p>Results in a Neo4j node <code>(:person:Character{name:'Camina Drummer'})</code></p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class AddLabel(_NodeTransformerBase):\n\"\"\"Add one or more new labels to nodes\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina Drummer\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_node(\"person\").do(NodeTrans.AddLabel(\"Character\"))\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:person:Character{name:'Camina Drummer'})`\n    \"\"\"\ndef __init__(self, labels: Union[str, List[str]]):\n\"\"\"_summary_\n        Args:\n            labels (Union[str, List[str]]): A string or a list of strings that will be added as new labels to the matched nodes\n        \"\"\"\nif isinstance(labels, str):\nlabels = [labels]\nself.new_labels = labels\ndef transform_node(self, node: Node):\nnode.labels = node.labels + self.new_labels\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.AddLabel.__init__","title":"<code>__init__(labels)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>Union[str, List[str]]</code> <p>A string or a list of strings that will be added as new labels to the matched nodes</p> required Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(self, labels: Union[str, List[str]]):\n\"\"\"_summary_\n    Args:\n        labels (Union[str, List[str]]): A string or a list of strings that will be added as new labels to the matched nodes\n    \"\"\"\nif isinstance(labels, str):\nlabels = [labels]\nself.new_labels = labels\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.CapitalizeLabels","title":"<code>CapitalizeLabels</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Uppercase the first char of a node Labels. Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina Drummer\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_node(\"person\").do(NodeTrans.CapitalizeLabels())\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{name:'Camina Drummer'})</code></p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class CapitalizeLabels(_NodeTransformerBase):\n\"\"\"Uppercase the first char of a node Labels.\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina Drummer\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_node(\"person\").do(NodeTrans.CapitalizeLabels())\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{name:'Camina Drummer'})`\n    \"\"\"\ndef transform_node(self, node: Node):\nnode.labels = [label.capitalize() for label in node.labels]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.CreateHubbing","title":"<code>CreateHubbing</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class CreateHubbing(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(\nself,\nfollow_nodes_labels: List[str],\nmerge_property_mode: Literal[\"lead\", \"edge\"],\nhub_labels: List[str] = [\"Hub\"],\n):\nif len(follow_nodes_labels) &lt;= 1:\nraise ValueError(\nf\"At least chains of 3 node are needed for hubbing. Please provide min. 2 `follow_nodes_labels`. Got only {len(follow_nodes_labels)} labels\"\n)\nif merge_property_mode.upper() not in [\"LEAD\", \"EDGE\"]:\nraise ValueError(\nf\"Only 'lead' and 'edge' mode are supported. got '{merge_property_mode}'\"\n)\nself.follow_nodes_labels = follow_nodes_labels\nself.merge_property_mode = merge_property_mode\nif isinstance(hub_labels, str):\nhub_labels = [hub_labels]\nself.hub_labels = hub_labels\ndef custom_node_match(self, node: Node) -&gt; bool:\n# walk the node tree to check if this subtree needs to be hubbed.\n# if all follow_nodes_labels exists in the right order, according follow_nodes_labels, to we will hub\nreturn len(\nlist(self._walk_follow_nodes(node, self.follow_nodes_labels))\n) &gt;= len(self.follow_nodes_labels)\ndef transform_node(self, node: Node):\nhub = Node(labels=self.hub_labels, source_data={}, parent_node=node)\nstart_node: Node = node\nfill_nodes: List[Node] = []\nend_node: Node = None\nfor follow_node, follow_rel in self._walk_follow_nodes(\nnode, follow_nodes_labels=self.follow_nodes_labels\n):\nend_node = follow_node\nfill_nodes.append(follow_node)\nfollow_rel.start_node = hub\nfill_nodes.remove(end_node)\nhash_sources = []\nif self.merge_property_mode.upper() == \"EDGE\":\nhash_sources.append(start_node.get_hash())\nhash_sources.append(end_node.get_hash())\nelif self.merge_property_mode.upper() == \"LEAD\":\nhash_sources.extend([n.get_hash() for n in fill_nodes])\nhub[self.d2g.list_hub_id_property_name] = hashlib.md5(\n\"\".join(hash_sources).encode(\"utf-8\")\n).hexdigest()\nself.d2g._node_cache.append(hub)\nself.d2g._rel_cache.append(Relation(start_node=node, end_node=hub))\ndef _walk_follow_nodes(\nself, node: Node, follow_nodes_labels: List[str]\n) -&gt; Generator[Tuple[Node, Relation], None, None]:\nif len(follow_nodes_labels) == 0:\nreturn\nfor o_rel in [r for r in node.outgoing_relations if not r.deleted]:\nfor end_node_label in o_rel.end_node.labels:\nif end_node_label in follow_nodes_labels[0]:\nyield o_rel.end_node, o_rel\nfor n, r in self._walk_follow_nodes(\no_rel.end_node,\n[l for l in follow_nodes_labels if l != end_node_label],\n):\nyield n, r\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.CreateNewMergePropertyFromHash","title":"<code>CreateNewMergePropertyFromHash</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class CreateNewMergePropertyFromHash(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(\nself,\nhash_includes_properties: List[str] = None,\nhash_includes_existing_merge_props: bool = False,\nhash_includes_existing_other_props: bool = False,\nhash_includes_children_nodes_merge_properties: bool = False,\nhash_includes_children_nodes_merge_data: bool = False,\nhash_includes_parent_merge_properties: bool = False,\nnew_merge_property_name: str = \"_id\",\n):\nself.hash_includes_existing_merge_props = hash_includes_existing_merge_props\nself.hash_includes_existing_other_props = hash_includes_existing_other_props\nself.hash_includes_properties = hash_includes_properties\nself.hash_includes_children_nodes_merge_properties = (\nhash_includes_children_nodes_merge_properties\n)\nself.hash_includes_children_nodes_merge_data = (\nhash_includes_children_nodes_merge_data\n)\nself.hash_includes_children_nodes_merge_data = (\nhash_includes_children_nodes_merge_data\n)\nself.hash_includes_parent_merge_properties = (\nhash_includes_parent_merge_properties\n)\nself.new_merge_property_name = new_merge_property_name\ndef transform_node(self, node: Node):\nif self.hash_includes_properties:\nnode.merge_property_keys = list(\nset(node.merge_property_keys + self.hash_includes_properties)\n)\nnode[self.new_merge_property_name] = node.get_hash(\ninclude_properties=self.hash_includes_properties,\ninclude_merge_properties=self.hash_includes_existing_merge_props,\ninclude_other_properties=self.hash_includes_existing_other_props,\ninclude_parent_properties=self.hash_includes_parent_merge_properties,\ninclude_children_properties=self.hash_includes_children_nodes_merge_properties,\ninclude_children_data=self.hash_includes_children_nodes_merge_data,\n)\nnode.merge_property_keys = [self.new_merge_property_name]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.MergeChildNodes","title":"<code>MergeChildNodes</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class MergeChildNodes(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(\nself,\nchild_labels: Union[str, AnyLabel] = AnyLabel,\nchild_relation_type: Union[str, AnyRelation] = AnyRelation,\noverwrite_existing_props: bool = True,\nprefix_merged_props_with_primary_label_of_child: bool = False,\nprefix_merged_props_with_hash_of_child: bool = False,\ninclude_relation_props: bool = True,\n):\nself.child_labels = child_labels\nself.child_relation_type = child_relation_type\nself.overwrite_existing_props = overwrite_existing_props\nself.prefix_merged_props_with_primary_label = (\nprefix_merged_props_with_primary_label_of_child\n)\nself.prefix_merged_props_with_hash_of_child = (\nprefix_merged_props_with_hash_of_child\n)\nself.include_relation_props = include_relation_props\ndef transform_node(self, node: Node):\nfor outgoing_rel in node.outgoing_relations:\nchild_node = outgoing_rel.end_node\nif not (\nself.child_labels == AnyLabel\nor set(self.child_labels).issubset(set(child_node.labels))\n):\ncontinue\nif not (\nself.child_relation_type == AnyRelation\nor outgoing_rel.relation_type == self.child_relation_type\n):\ncontinue\nif self.include_relation_props:\nself._merge_props(target_node=node, obj=outgoing_rel)\nself._merge_props(target_node=node, obj=child_node)\nfor outgoing_child_rel in child_node.outgoing_relations:\noutgoing_child_rel.start_node = node\nfor incoming_child_rel in child_node.incoming_relations:\nif incoming_child_rel.start_node != node:\nincoming_child_rel.start_node = node\nelse:\nincoming_child_rel.deleted = True\nchild_node.deleted = True\ndef _merge_props(\nself,\ntarget_node: Node,\nobj: Union[Node, Relation],\n):\nfor key, val in obj.items():\nresult_key = key\nif self.prefix_merged_props_with_primary_label:\nprefix = (\nobj.primary_label if isinstance(obj, Node) else obj.relation_type\n)\nresult_key = f\"{prefix}_{result_key}\"\nif self.prefix_merged_props_with_hash_of_child and isinstance(obj, Node):\nresult_key = f\"{obj.get_hash()}_{result_key}\"\nif key in target_node and not self.overwrite_existing_props:\nmax_index = max(\n[\nk.split(\"_\")[-1]\nfor k in list(target_node.keys())\nif k.startswith(key) and k.split(\"_\")[-1].isnumeric()\n],\ndefault=\"-1\",\n)\nresult_key = f\"{result_key}_{int(max_index)+1}\"\ntarget_node[result_key] = val\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.OutsourcePropertiesToNewNode","title":"<code>OutsourcePropertiesToNewNode</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class OutsourcePropertiesToNewNode(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(\nself,\nproperty_keys: List[str],\nnew_node_labels: List[str],\nrelation_type: str = None,\nskip_if_keys_empty: bool = True,\n):\nself.property_keys = property_keys\nself.new_node_labels = new_node_labels\nself.relation_type = relation_type\nself.skip_if_keys_empty = skip_if_keys_empty\ndef transform_node(self, node: Node):\noutsourced_props_node: Node = Node(\nlabels=self.new_node_labels, source_data={}, parent_node=node\n)\nfor key in self.property_keys:\nif key in node:\noutsourced_props_node[key] = node.pop(key)\nif not outsourced_props_node and self.skip_if_keys_empty:\nreturn\nself.d2g._node_cache.append(outsourced_props_node)\nself.d2g._rel_cache.append(\nRelation(node, outsourced_props_node, relation_type=self.relation_type)\n)\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.OutsourcePropertiesToRelationship","title":"<code>OutsourcePropertiesToRelationship</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class OutsourcePropertiesToRelationship(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(\nself,\nproperty_keys: List[str],\nrelation_type: str = None,\nskip_if_keys_empty: bool = True,\nkeep_prop_if_relation_does_not_exist: bool = True,\n):\nself.property_keys = property_keys\nself.relation_type = relation_type\nself.skip_if_keys_empty = skip_if_keys_empty\nself.keep_prop_if_relation_does_not_exist = keep_prop_if_relation_does_not_exist\ndef transform_node(self, node: Node):\nfor rel in node.relations:\nif rel.relation_type == self.relation_type:\nfor prop in self.property_keys:\nif prop in node and (\nnode[prop] not in [\"\", None] or not self.skip_if_keys_empty\n):\nrel[prop] = node.pop(prop)\nif not self.keep_prop_if_relation_does_not_exist:\n[node.pop(prop, None) for prop in self.property_keys]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.OverrideLabel","title":"<code>OverrideLabel</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Replace a node label with a new string    Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina Drummer\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_node(\"person\").do(NodeTrans.OverrideLabel(\"Character\"))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Character{name:'Camina Drummer'})</code></p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class OverrideLabel(_NodeTransformerBase):\n\"\"\"Replace a node label with a new string    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina Drummer\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_node(\"person\").do(NodeTrans.OverrideLabel(\"Character\"))\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Character{name:'Camina Drummer'})`\n    \"\"\"\ndef __init__(self, value: str, target_label: str = None):\n\"\"\"_summary_\n        Args:\n            value (str): The new labels string.\n            target_label (str, optional): The label you want to be replaced.\n                If none, the labels defined in the `node_match()` function will be replaced.\n                Defaults to None.\n        Raises:\n            ValueError: _description_\n        \"\"\"\nif not value:\nraise ValueError(f\"Value must be a string. Got '{value}'\")\nself.value = value\nself.target_label = target_label\ndef transform_node(self, node: Node):\nif self.target_label:\nreplace_labels = [self.target_label]\nelse:\nreplace_labels = self.matcher.label_match\nfor origin_label in replace_labels:\nnode.labels = list(\nmap(lambda x: x.replace(origin_label, self.value), node.labels)\n)\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.OverrideLabel.__init__","title":"<code>__init__(value, target_label=None)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The new labels string.</p> required <code>target_label</code> <code>str</code> <p>The label you want to be replaced. If none, the labels defined in the <code>node_match()</code> function will be replaced. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(self, value: str, target_label: str = None):\n\"\"\"_summary_\n    Args:\n        value (str): The new labels string.\n        target_label (str, optional): The label you want to be replaced.\n            If none, the labels defined in the `node_match()` function will be replaced.\n            Defaults to None.\n    Raises:\n        ValueError: _description_\n    \"\"\"\nif not value:\nraise ValueError(f\"Value must be a string. Got '{value}'\")\nself.value = value\nself.target_label = target_label\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.PopListHubNodes","title":"<code>PopListHubNodes</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>When dict2grapg parses dict lists it create a hub node to attach all list items. In most cases this is unnecessary and will make your graph model larger as it has to be. <code>PopListHubNodes</code> will just remove these list hubs.</p> <p>Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata = {\n\"bookshelf\": {\n\"book\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n\"condition\": \"good\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n\"condition\": \"bad\",\n},\n]\n}\n}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_node().do(NodeTrans.PopListHubNodes())\n)\nd2g.parse(data)\nd2g.create(NEO4J_DRIVER)\n</code></pre></p> <p>This will result in a <code>(:bookshelf)</code>node directly connected to 2 <code>(:book)</code> nodes instead of a <code>:ListHub:book</code> node in between.</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class PopListHubNodes(_NodeTransformerBase):\n\"\"\"When dict2grapg parses dict lists it create a hub node to attach all list items.\n    In most cases this is unnecessary and will make your graph model larger as it has to be.\n    `PopListHubNodes` will just remove these list hubs.\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    data = {\n        \"bookshelf\": {\n            \"book\": [\n                {\n                    \"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n                    \"condition\": \"good\",\n                },\n                {\n                    \"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n                    \"condition\": \"bad\",\n                },\n            ]\n        }\n    }\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_node().do(NodeTrans.PopListHubNodes())\n    )\n    d2g.parse(data)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    This will result in a `(:bookshelf)`node directly connected to 2 `(:book)` nodes instead of a `:ListHub:book` node in between.\n    \"\"\"\ndef custom_node_match(self, node: Node) -&gt; bool:\nreturn node.is_list_list_hub\ndef transform_node(self, node: Node):\nnew_list_item_nodes_parent = node.parent_node\nfor list_item_rel in node.outgoing_relations:\nif new_list_item_nodes_parent is not None:\nlist_item_rel.start_node = new_list_item_nodes_parent\nelse:\n# we are at the root node level. the list will now without any parent.\nlist_item_rel.deleted\nfor parent_rels in node.incoming_relations:\nparent_rels.deleted = True\nnode.deleted = True\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.PopNode","title":"<code>PopNode</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class PopNode(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef transform_node(self, node: Node):\nfor i_rel in node.incoming_relations:\nfor o_rel in node.outgoing_relations:\ni_rel.end_node = o_rel.end_node\nnode.deleted\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveEmptyListRootNodes","title":"<code>RemoveEmptyListRootNodes</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveEmptyListRootNodes(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef custom_node_match(self, node: Node) -&gt; bool:\nreturn node.is_list_list_hub and len(node.outgoing_relations) == 0\ndef transform_node(self, node: Node):\nfor rel in node.relations:\nrel.deleted = True\nnode.deleted = True\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveLabel","title":"<code>RemoveLabel</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Remove a certain label from nodes Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": [{\"name\": \"Camina Drummer\"},{\"name\":\"James Holden\"}]}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_node(\"person\").do(NodeTrans.RemoveLabel(\"ListItem\"))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre></p> <p>Results in removing the <code>:ListItem</code> label from <code>:Person</code> nodes</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveLabel(_NodeTransformerBase):\n\"\"\"Remove a certain label from nodes\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": [{\"name\": \"Camina Drummer\"},{\"name\":\"James Holden\"}]}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_node(\"person\").do(NodeTrans.RemoveLabel(\"ListItem\"))\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in removing the `:ListItem` label from `:Person` nodes\n    \"\"\"\ndef __init__(self, target_label: str = None):\n\"\"\"_summary_\n        Args:\n            target_label (str, optional): Optional set this if you dont want the labels from `match_node()` to be replaced. Defaults to None.\n        Raises:\n            ValueError: _description_\n        \"\"\"\nself.target_label = target_label\ndef transform_node(self, node: Node):\nif self.target_label == AnyLabel:\nnode.labels = []\nelif self.target_label is None:\nnode.labels = [l for l in node.labels if l not in self.matcher.label_match]\nelif isinstance(self.target_label, str):\nnode.labels = [l for l in node.labels if l != self.target_label]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveLabel.__init__","title":"<code>__init__(target_label=None)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>target_label</code> <code>str</code> <p>Optional set this if you dont want the labels from <code>match_node()</code> to be replaced. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(self, target_label: str = None):\n\"\"\"_summary_\n    Args:\n        target_label (str, optional): Optional set this if you dont want the labels from `match_node()` to be replaced. Defaults to None.\n    Raises:\n        ValueError: _description_\n    \"\"\"\nself.target_label = target_label\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveListItemLabels","title":"<code>RemoveListItemLabels</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveListItemLabels(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef custom_node_match(self, node: Node) -&gt; bool:\nreturn node.is_list_list_item\ndef transform_node(self, node: Node):\nnode.labels = [\nl for l in node.labels if l not in self.d2g.list_item_additional_labels\n]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveNode","title":"<code>RemoveNode</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveNode(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(self, remove_children: bool = False):\nself.remove_children = remove_children\ndef transform_node(self, node: Node):\nnode.deleted = True\nfor o_rel in node.outgoing_relations:\no_rel.deleted = True\nif self.remove_children:\nself.transform_node(o_rel.end_node)\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveNodesWithNoProps","title":"<code>RemoveNodesWithNoProps</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveNodesWithNoProps(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(self, only_if_no_child_nodes: bool = True):\nself.only_if_no_child_nodes = only_if_no_child_nodes\ndef transform_node(self, node: Node):\nif len(node.keys()) == 0 and (\nnot self.only_if_no_child_nodes or len(node.outgoing_relations) == 0\n):\nnode.deleted = True\nfor o_rel in node.relations:\no_rel.deleted = True\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveNodesWithOnlyEmptyProps","title":"<code>RemoveNodesWithOnlyEmptyProps</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveNodesWithOnlyEmptyProps(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(self, only_if_no_child_nodes: bool = True):\nself.only_if_no_child_nodes = only_if_no_child_nodes\ndef transform_node(\nself,\nnode: Node,\n):\nif set(node.values()) in [set([None]), set([\"\"]), set([None, \"\"])]:\nif not self.only_if_no_child_nodes or len(node.outgoing_relations) == 0:\nnode.deleted = True\nfor o_rel in node.outgoing_relations:\no_rel.deleted = True\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.SetMergeProperties","title":"<code>SetMergeProperties</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Set the primary properties that will be taken into account when comparing nodes while merging them together. <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata = {\n\"books\": [\n{\n\"title\": \"Science Behind The Cyberpunks-Genre Awesomeness\",\n},\n{\n\"title\": \"Science Behind The Cyberpunks-Genre Awesomeness\",\n}\n]\n}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_node([\"books\", \"ListItem\"]).do(\nNodeTrans.SetMergeProperties(props=[\"title\"])\n)\n)\nd2g.parse(data)\nd2g.merge(NEO4J_DRIVER)\n</code></pre></p> <p>Will result in one Node <code>(:book)</code> because we only compare by the property <code>title</code> when mergin nodes together.</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class SetMergeProperties(_NodeTransformerBase):\n\"\"\"Set the primary properties that will be taken into account when comparing nodes while merging them together.\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    data = {\n        \"books\": [\n            {\n                \"title\": \"Science Behind The Cyberpunks-Genre Awesomeness\",\n            },\n            {\n                \"title\": \"Science Behind The Cyberpunks-Genre Awesomeness\",\n            }\n        ]\n    }\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_node([\"books\", \"ListItem\"]).do(\n            NodeTrans.SetMergeProperties(props=[\"title\"])\n        )\n    )\n    d2g.parse(data)\n    d2g.merge(NEO4J_DRIVER)\n    ```\n    Will result in one Node `(:book)` because we only compare by the property `title` when mergin nodes together.\n    \"\"\"\ndef __init__(self, props: List[str]):\n\"\"\"\n        Args:\n            props (List[str]): A list of property keys to take into account for merging.\n        \"\"\"\nself.props = props\ndef transform_node(self, node: Node):\nnode.merge_property_keys = self.props\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.SetMergeProperties.__init__","title":"<code>__init__(props)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>props</code> <code>List[str]</code> <p>A list of property keys to take into account for merging.</p> required Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(self, props: List[str]):\n\"\"\"\n    Args:\n        props (List[str]): A list of property keys to take into account for merging.\n    \"\"\"\nself.props = props\n</code></pre>"},{"location":"list_rel_transformer/","title":"Relationship Transformers","text":"<p>dict2graph comes with a lot of predefined transformators. For a basic concepts of a dict2Graph transformators have a look at How to use Transformators</p>"},{"location":"list_rel_transformer/#relationship-transformators-list","title":"Relationship Transformators List","text":"<p>This is a list if transformators that can be applied to relationships only </p>"},{"location":"list_rel_transformer/#dict2graph.transformers.rel_transformers.FlipNodes","title":"<code>FlipNodes</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/rel_transformers.py</code> <pre><code>class FlipNodes(_RelationTransformerBase):\n\"\"\"_summary_\"\"\"\ndef transform_rel(self, rel: Relation):\nstart_node = rel.start_node\nend_node = rel.end_node\nfor inc_rel in start_node.incoming_relations:\ninc_rel.end_node = end_node\nfor out_rel in end_node.outgoing_relations:\nout_rel.start_node = start_node\nrel.start_node = rel.end_node\nrel.end_node = start_node\n</code></pre>"},{"location":"list_rel_transformer/#dict2graph.transformers.rel_transformers.OverrideReliationType","title":"<code>OverrideReliationType</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/rel_transformers.py</code> <pre><code>class OverrideReliationType(_RelationTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(self, value: str = None):\nif not value:\nraise ValueError(f\"Value must be a string. Got '{value}'\")\nself.value = value\ndef transform_rel(self, rel: Relation):\nrel.relation_type = self.value\n</code></pre>"},{"location":"list_rel_transformer/#dict2graph.transformers.rel_transformers.UppercaseRelationType","title":"<code>UppercaseRelationType</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/rel_transformers.py</code> <pre><code>class UppercaseRelationType(_RelationTransformerBase):\n\"\"\"_summary_\"\"\"\ndef transform_rel(self, rel: Relation):\nrel.relation_type = rel.relation_type.upper()\n</code></pre>"},{"location":"use_transformers/","title":"Transforming","text":""},{"location":"use_transformers/#what-is-transforming-in-dict2graph","title":"What is transforming in dict2graph","text":"<p>Internally dict2graph is caching all parsed content before passing it down to GraphIO, which loads it into Neo4j. This enables us to influence the model in the dict2graph cache before anything goes to Neo4j. In many usecases this can be more perfomant or just more convenient compared to reshaping the model after its loaded into Neo4j.</p> <p>This \"pre\"-transforming will not cover all use-cases nore will it be more perfomant in all cases. You need to find the right balance.</p>"},{"location":"use_transformers/#how-to-use","title":"How to use","text":"<p>The workflow is:</p> <ul> <li>Create a match/filter for the nodes and relationships you want to manipulate </li> <li>Create a transformer to these nodes and relationships</li> <li>Add the transformer to your <code>Dict2graph</code> instance</li> <li>Parse and load your dict/data</li> </ul>"},{"location":"use_transformers/#matching","title":"Matching","text":"<p>The first step to transform your model is to find the parts you want to manipulate. In dict2graph this is accomplished by matching or filtering nodes and relationships</p> <p><code>TransformMatcher</code>s  are targeting the resulting graph-node labels and relationship-types. To design your <code>TransformMatcher</code> it is recommended to start with a plain run of dict2graph with your data. You then can inspect the resulting nodes and relationships and build matchers to transform these.</p> <p>Hint</p> <p>At the moment matching is very basic. It only cover <code>labels</code> for nodes and <code>types</code> for relationships. Probably there will be more advanced matcher and filters in future versions.</p> <p>Lets imagen we have a dict like the following</p> <pre><code>data = {\n\"bookshelf\": {\n\"Genre\": \"Explaining the world\",\n\"books\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n},\n]\n}\n}\n</code></pre> <p>As a first step lets load it into a neo4j database:</p> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2Graph\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata = {\n\"bookshelf\": {\n\"Genre\": \"Explaining the world\",\n\"books\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n},\n]\n}\n}\nd2g = Dict2graph()\nd2g.parse(data)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>This result in the following graph</p> <p></p>"},{"location":"use_transformers/#node-matching","title":"Node Matching","text":"<p>The most simple matcher you can build is a \"match everything\" case. Matching everything is also the default case. Just keep the matcher empty.</p> <pre><code>from dict2graph import Transformer, AnyNode\nall_matcher = Transformer.match_node()\n# this is equal to \nall_matcher = Transformer.match_node(AnyNode)\n</code></pre> <p>If we wanted to change <code>(:books)</code> nodes only we would build a matcher like this:</p> <pre><code>from dict2graph import Transformer\nbooks_matcher = Transformer.match_node(\"books\")\n</code></pre> <p>Or we can even match multiple nodes by providing multiples labels.</p> <p><pre><code>from dict2graph import Transformer\nbook_and_shelf_matcher = Transformer.match_node(has_one_label_of=[\"books\",\"bookshelf\"])\n</code></pre> This would match <code>(:books)</code> and <code>(:bookshelf)</code> nodes.</p> <p>Filtering out certain labels is also possible <pre><code>from dict2graph import Transformer\nno_bookshelf_matcher = Transformer.match_node(has_none_label_of=[\"bookshelf\"])\n</code></pre> This again, would match only the <code>(:books)</code>-nodes.</p>"},{"location":"use_transformers/#relationship-matching","title":"Relationship matching","text":"<p>Relationship matching works similar to node matching but it is maybe even simpler. </p> <p>As a starter lets see how we match all relationships:</p> <pre><code>from dict2graph import Transformer\nall_rels_matcher = Transformer.match_rel()\n</code></pre> <p>which is equal to </p> <pre><code>from dict2graph import Transformer, AnyRelation\nall_rels_matcher = Transformer.match_rel(AnyRelation)\n</code></pre> <p>Now lets match our <code>bookshelf_HAS_books</code> relations.</p> <pre><code>from dict2graph import Transformer\nshelf2book_matcher = Transformer.match_rel(\"bookshelf_HAS_books\")\n</code></pre> <p>Or how about matching both of our relations?</p> <pre><code>from dict2graph import Transformer\nboth_matcher = Transformer.match_rel(\n[\"bookshelf_HAS_books\", \"bookshelf_LIST_HAS_books\"]\n)\n</code></pre> <p>Of course filtering is possible as well. lets filter <code>bookshelf_HAS_books</code> away</p> <pre><code>from dict2graph import Transformer\nfilter_matcher = Transformer.match_rel(\nrelation_type_is_not_in=[\"bookshelf_HAS_books\"]\n)\n</code></pre>"},{"location":"use_transformers/#transforming","title":"Transforming","text":"<p>Great. Now as you know how to collect your nodes and relationships, lets manipulate them. Fot that we need to create so called <code>Transformer</code>s</p> <p>Lets add a new property \"<code>material: 'wood'</code>\" to our bookshelf.</p> <p>We will pick the dict2graph built in node transformer AddProperty</p> <p>For your convenience you can import the wrapper class <code>dict2graph.NodeTrans</code> which includes all Transformers that are applicable to nodes. Same with <code>dict2graph.RelTrans</code> for relationship transformators.</p> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2graph,Transformer, NodeTrans\ndata = {\n\"bookshelf\": {\n\"Genre\": \"Explaining the world\",\n\"books\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n},\n]\n}\n}\n# we just learned how to \"match\". lets apply it:\nbookshelf_matcher = Transformer.match_node(\"bookshelf\")\nadd_prop_transformator = NodeTrans.AddProperty({\"material\":\"wood\"})\n# the next thing we should do is to attach the transformator to our dict2graph instance\nmatch_and_transform = bookshelf_matcher.do(add_prop_transformator)\n# to be able to enjoy our work lets push the data to neo4j\n# From here this works the same way as we allready learned in the basic tutorial\nd2g = Dict2graph()\nd2g.add_transformation(match_and_transform)\n# parse our dict...\nd2g.parse(data)\n# ...and push it to the database\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>If we now query our Neo4j database with </p> <pre><code>MATCH (bs:bookshelf) return bs.material\n</code></pre> <p>we get</p> <pre><code>[\n{\n\"bs.material\": \"wood\"\n}\n]\n</code></pre> <p>as a return value</p>"},{"location":"use_transformers/#compact-variant","title":"Compact variant","text":"<p>Lets tidy up our code.</p> <p>The same code we just wrote can also look like this:</p> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2graph, Transformer, NodeTrans\ndata = {\n\"bookshelf\": {\n\"Genre\": \"Explaining the world\",\n\"books\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n},\n],\n}\n}\nd2g = Dict2graph()\nd2g.add_transformation(\nTransformer.match_node(\"bookshelf\").do(NodeTrans.AddProperty({\"material\": \"wood\"}))\n)\nd2g.parse(data)\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>this is much more compact and depending on your taste more readable. But its just a style question. Choice is yours.</p>"},{"location":"use_transformers/#order-matters","title":"Order matters!","text":"<p>The sequence of your transformers matters. Any transformation is passed to the next transformator.</p> <p>Lets compare to very similar code snippets. The only differentce will be the sequence of our transformators.</p> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2graph, Transformer, NodeTrans\ndata = {\"bookshelf\": {\"Genre\": \"Explaining the world\"}}\nd2g = Dict2graph()\nd2g.add_transformation(\n[\nTransformer.match_node(\"bookshelf\").do(NodeTrans.AddProperty({\"mtr\": \"wood\"})),\nTransformer.match_node(\"bookshelf\").do(\nNodeTrans.OverridePropertyName(\"mtr\", \"material\")\n),\n]\n)\nd2g.parse(data)\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>The result of </p> <pre><code>MATCH (bs:bookshelf) return bs\n</code></pre> <p>will be </p> <pre><code>\u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n\u2502\"bs\"                                              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502{\"material\":\"wood\",\"Genre\":\"Explaining the world\"}\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2graph, Transformer, NodeTrans\ndata = {\"bookshelf\": {\"Genre\": \"Explaining the world\"}}\nd2g = Dict2graph()\nd2g.add_transformation(\n[\nTransformer.match_node(\"bookshelf\").do(\nNodeTrans.OverridePropertyName(\"mtr\", \"material\")\n),\nTransformer.match_node(\"bookshelf\").do(NodeTrans.AddProperty({\"mtr\": \"wood\"})),\n]\n)\nd2g.parse(data)\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>The result of </p> <pre><code>MATCH (bs:bookshelf) return bs\n</code></pre> <p>will be </p> <pre><code>\u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n\u2502\"bs\"                                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502{\"mtr\":\"wood\",\"Genre\":\"Explaining the world\"}\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You see in the first case we added the new property first and then renamed it.</p> <p>In the second case we tried to rename it first. but it was not available yet, as the node Transformator <code>AddProperty</code> came after <code>OverridePropertyName</code></p> <p>So keep that in mind when chaining transformations.</p>"},{"location":"api/api_dict2graph/","title":"Dict2Graph","text":""},{"location":"api/api_dict2graph/#dict2graph.Dict2graph","title":"<code>dict2graph.Dict2graph</code>","text":"Source code in <code>dict2graph/dict2graph.py</code> <pre><code>class Dict2graph:\n# Replacement strings {ITEM_PRIMARY_LABEL} and {ITEM_LABELs} are available\nlist_hub_additional_labels: List[str] = [\"ListHub\"]\nlist_item_additional_labels: List[str] = [\"ListItem\"]\nlist_hub_id_property_name: str = \"id\"\nlist_item_relation_index_property_name: str = \"_list_item_index\"\nsimple_list_item_data_property_name: str = \"_list_item_data\"\nroot_node_default_labels: List[str] = [\"Dict2GraphRoot\"]\nroot_node_default_id_property_name = \"id\"\nempty_node_default_id_property_name = \"id\"\ndef __init__(\nself,\ncreate_ids_for_empty_nodes: bool = True,\ninterpret_single_props_as_labels: bool = True,\n):\n\"\"\"Main class for dict2graph. Instance Dict2graph to get access to the API.\n        Usage:\n        ```python\n        from dict2graph import Dict2graph\n        d2g = Dict2Graph()\n        ```\n        Args:\n            create_ids_for_empty_nodes (bool, optional): When input dicts results in empty 'hub' nodes, this will create artificially key properties based on the child data. The key will be deterministic . Defaults to True.\n            interpret_single_props_as_labels (bool, optional): When having object with a single property like `{\"animal\":{\"name\":\"dog\"}}` `animal` will be interpreted as label. If set to false \"animal\" will result in an extra Node. Defaults to True.\n        \"\"\"\nself.create_ids_for_empty_nodes = create_ids_for_empty_nodes\n# Todo: \"interpret_single_props_as_labels\" should be a regualr NodeTransformer instead of a class param\nself.interpret_single_props_as_labels = interpret_single_props_as_labels\nself._node_cache: List[Node] = []\nself._rel_cache: List[Relation] = []\nself._nodeSets: Dict[Tuple, NodeSet] = {}\nself._relSets: Dict[Tuple, RelationshipSet] = {}\nself.node_transformators: List[_NodeTransformerBase] = []\nself.relation_transformators: List[_RelationTransformerBase] = []\ndef add_transformation(\nself,\ntransformator: Union[\n_NodeTransformerBase,\n_RelationTransformerBase,\nList[Union[_NodeTransformerBase, _RelationTransformerBase]],\n],\n):\n\"\"\"Add a [`Transformers`](dict2graph/use_transformers.md) to the Dict2Graph instance.\n        Transformers can re-model your graph befor writing it to a Neo4h database.\n        usage:\n        ```python\n        from dict2graph import Dict2graph, Transformer, NodeTrans\n        d2g = Dict2Graph()\n        d2g.add_transformation(\n            Transformer.match_node(\"article\").do(NodeTrans.OverrideLabel(\"book\"))\n        )\n        ```\n        Args:\n            transformator (Union[ _NodeTransformerBase, _RelationTransformerBase, List[Union[_NodeTransformerBase, _RelationTransformerBase]], ]): A list or single instance of a Transformer\n        \"\"\"\nif isinstance(transformator, list):\nfor trans in transformator:\nself.add_transformation(trans)\nif issubclass(transformator.__class__, _NodeTransformerBase) or (\nissubclass(\ntransformator.__class__,\n_NodeTransformerBase,\n)\nand issubclass(transformator.__class__, _RelationTransformerBase)\n):\nself.add_node_transformation(transformator)\nelif issubclass(transformator.__class__, _RelationTransformerBase):\nself.add_relation_transformation(transformator)\ndef add_node_transformation(\nself, transformator: Union[_NodeTransformerBase, List[_NodeTransformerBase]]\n):\nif isinstance(transformator, list):\nfor trans in transformator:\nself.add_node_transformation(trans)\nreturn\nif not issubclass(transformator.__class__, _NodeTransformerBase):\nraise ValueError(\nf\"Expected transformer of subclass '{_NodeTransformerBase}', got '{transformator.__class__}' (child of '{transformator.__class__.__bases__}').\\nMaybe you wanted to use function `Dict2graph.add_relation_transformation()` instead of `add_node_transformation`?\"\n)\nelif transformator.matcher.__class__ != Transformer.NodeTransformerMatcher:\nraise ValueError(\nf\"Expected transformer matcher of class '{Transformer.NodeTransformerMatcher}', got '{transformator.matcher.__class__}'.\\nMaybe you accidentally added a relationship matcher instead of a node matcher (`match_node()` vs. `match_rel()`) while using `Dict2graph.add_node_transformation()`?\"\n)\nelse:\ntransformator.d2g = self\nself.node_transformators.append(transformator)\ndef add_relation_transformation(\nself,\ntransformator: Union[_RelationTransformerBase, List[_RelationTransformerBase]],\n):\nif isinstance(transformator, list):\nfor trans in transformator:\nself.add_relation_transformation(trans)\nelif not issubclass(transformator.__class__, _RelationTransformerBase):\nraise ValueError(\nf\"Expected transformer of subclass '{_RelationTransformerBase}', got '{transformator.__class__}' (child of '{transformator.__class__.__bases__}').\\nMaybe you wanted to use function `Dict2graph.add_node_transformation()` instead of `add_relation_transformation`?\"\n)\nelif transformator.matcher.__class__ != Transformer.RelTransformerMatcher:\nraise ValueError(\nf\"Expected transformer matcher of class '{Transformer.RelTransformerMatcher}', got '{transformator.matcher.__class__}'.\\nMaybe you accidentally added a node matcher instead of a relationship matcher (`match_rel()` vs. `match_node()`) while using `Dict2graph.add_relation_transformation()`?\"\n)\nelse:\nself.relation_transformators.append(transformator)\ndef parse(\nself, data: Dict, root_node_labels: Union[str, List[str]] = None\n) -&gt; \"Dict2graph\":\nif root_node_labels is None:\nif isinstance(data, dict) and len(data.keys()) == 1:\n# we only have one key and therefore only one Node on the top-/root-level. We dont need a root Node to connect the toplevels nodes.\nroot_node_labels = [list(data.keys())[0]]\ndata = data[root_node_labels[0]]\nelse:\nroot_node_labels = self.root_node_default_labels\nif isinstance(root_node_labels, str):\nroot_node_labels = [root_node_labels]\nif isinstance(data, str):\ndata_obj = json.loads(data)\nelse:\ndata_obj = data\nif not isinstance(data_obj, dict) and not isinstance(data_obj, list):\nraise ValueError(\n\"Expected json compatible object like a dict or list. got {}\".format(\ntype(data_obj).__name__\n)\n)\nif isinstance(data_obj, dict):\nroot_node = self._parse_traverse_dict_fragment(\nlabels=root_node_labels, data=data_obj, parent_node=None\n)\nelif isinstance(data_obj, list):\nroot_node = self._parse_traverse_list_fragment(\nlabels=root_node_labels, data=data_obj, parent_node=None\n)\nself._prepare_root_node(root_node)\nself._flush_cache()\nreturn self\ndef merge(self, graph: Union[Graph, Driver]):\nfor nodes in self._nodeSets.values():\nnodes.merge(graph)\nfor rels in self._relSets.values():\nrels.merge(graph)\ndef create(self, graph: Union[Graph, Driver]):\nfor nodes in self._nodeSets.values():\nnodes.create(graph)\nfor rels in self._relSets.values():\nrels.create(graph)\ndef _prepare_root_node(self, node: Node):\nnode.is_root_node = True\nif len(node.keys()) == 0:\nnode[self.root_node_default_id_property_name] = node.get_hash(\ninclude_children_data=True\n)\nnode.merge_property_keys = [self.root_node_default_id_property_name]\ndef _parse_traverse_dict_fragment(\nself, data: Dict, parent_node: Node, labels: List[str] = None\n) -&gt; Node:\nnew_node = Node(labels=labels, source_data=data, parent_node=parent_node)\nnew_child_nodes: List[Node] = []\nnew_rels: List[Relation] = []\nfor key, val in data.items():\nif self._is_basic_attribute_type(val):\n# value is a simple type. attach as property to node\nnew_node[key] = val\nelse:\n# value is dict or list in itself and therefore one or multiple child nodes\nr = None\nn = None\nif isinstance(val, dict):\nif self._is_named_obj(val):\nn = self._parse_traverse_dict_fragment(\nlabels=list(val.keys()),\ndata=val[list(val.keys())[0]],\nparent_node=new_node,\n)\nr = Relation(start_node=new_node, end_node=n, relation_type=key)\nelse:\nn = self._parse_traverse_dict_fragment(\nlabels=[key], data=val, parent_node=new_node\n)\nelif isinstance(val, list):\nn = self._parse_traverse_list_fragment(\nlabels=[key], data=val, parent_node=new_node\n)\nif n is not None:\nnew_child_nodes.append(n)\nif r is None:\nr = Relation(\nstart_node=new_node,\nend_node=n,\n)\nnew_rels.append(r)\nself._node_cache.append(new_node)\nself._rel_cache.extend(new_rels)\nreturn new_node\ndef _parse_traverse_list_fragment(\nself, labels: List[str], parent_node: Node, data: Dict\n) -&gt; Node:\n# create/set list root node. this is the node on which the list items will attach to\n# the parent_node is the default root\nlist_root_hub_node: Node = Node(\nlabels=labels,\nsource_data=data,\nparent_node=parent_node,\n)\nself._set_list_root_hub_node_labels(list_root_hub_node)\nlist_root_hub_node.is_list_list_hub = True\nself._node_cache.append(list_root_hub_node)\n# parse nodes\nnew_list_item_nodes: List[Node] = []\nfor index, obj in enumerate(data):\nif self._is_basic_attribute_type(obj):\nn = Node(labels, source_data=obj, parent_node=list_root_hub_node)\nn[self.simple_list_item_data_property_name] = obj\nself._node_cache.append(n)\nnew_list_item_nodes.append(n)\nelif self._is_named_obj(obj):\nobj_label = list(obj.keys())[0]\nobj_data = obj[obj_label]\nnew_list_item_nodes.append(\nself._parse_traverse_dict_fragment(\nlabels=obj_label, data=obj_data, parent_node=list_root_hub_node\n)\n)\nelif isinstance(obj, dict):\nnew_list_item_nodes.append(\nself._parse_traverse_dict_fragment(\nlabels=labels, data=obj, parent_node=list_root_hub_node\n)\n)\nelif isinstance(obj, list):\nnew_list_item_nodes.append(\nself._parse_traverse_list_fragment(\nlabels=labels, data=obj, parent_node=list_root_hub_node\n)\n)\n# create relations to list root node\nchild_ids: List[str] = []\nfor index, node in enumerate(new_list_item_nodes):\nif node is None:\ncontinue\nself._set_list_item_node_labels(node)\nnode.is_list_list_item = True\nchild_ids.append(node.id)\nr = Relation(\nstart_node=list_root_hub_node,\nend_node=node,\n)\nr[self.list_item_relation_index_property_name] = index\nnode.parent_node = list_root_hub_node\nself._rel_cache.append(r)\n#\nlist_root_hub_node[\nself.list_hub_id_property_name\n] = list_root_hub_node.get_hash(include_children_data=True)\nlist_root_hub_node.merge_property_keys = [self.list_hub_id_property_name]\nreturn list_root_hub_node\ndef _is_empty(self, val):\nif not val:\nreturn True\nif isinstance(val, str) and val.upper() in [\"\", \"NULL\"]:\nreturn True\nreturn False\ndef _is_basic_attribute_type(self, val):\nif isinstance(val, (str, int, float, bool)):\nreturn True\nelse:\nreturn False\ndef _is_named_obj(self, data: Dict):\n\"\"\"If an object is a one-keyd dict on the first layer and there is a dict behind this key,\n        we determine that this one key is the label/type and the inner dict are the props\n        Args:\n            data (List): _description_\n        Returns:\n            _type_: _description_\n        \"\"\"\n# {\"person\":{\"name\":\"tom\",\"lastname\":\"schilling\"}} -&gt; we know its a person\n# {\"name\":\"tom\",\"lastname\":\"schilling\"} -&gt; Could be a person or a lama\n# {\"client\":{\"name\":\"tom\",\"lastname\":\"schilling\"},\"cert\":\"yes\"} -&gt; -&gt; Could be a person or a computer\nif not self.interpret_single_props_as_labels:\nreturn False\nif (\nisinstance(data, dict)\nand len(data.keys()) == 1\nand isinstance(data[list(data.keys())[0]], dict)\n):\nreturn True\nreturn False\ndef _set_list_root_hub_node_labels(self, node: Node) -&gt; str:\naddi_labels = [\nl.replace(\"{{ITEM_PRIMARY_LABEL}}\", node.primary_label)\nfor l in self.list_hub_additional_labels\n]\naddi_labels = [\nl.replace(\"{{ITEM_LABELS}}\", \"_\".join(node.primary_label))\nfor l in addi_labels\n]\nnode.labels = node.labels + addi_labels\ndef _set_list_item_node_labels(self, node: Node) -&gt; str:\nnode.labels = node.labels + self.list_item_additional_labels\ndef _manifest_node_from_cache(self, cached_node: Node):\nnode_set: NodeSet = self._get_or_create_nodeSet(cached_node)\nif self.create_ids_for_empty_nodes and cached_node.id is None:\ncached_node[\nself.empty_node_default_id_property_name\n] = cached_node.get_hash(include_children_data=True)\ncached_node.merge_property_keys = [self.empty_node_default_id_property_name]\nnode_set.add_node(cached_node)\ndef _get_or_create_nodeSet(self, node: Node) -&gt; NodeSet:\nnode_type_fingerprint = frozenset(node.labels)\nif node_type_fingerprint not in self._nodeSets:\nself._nodeSets[node_type_fingerprint] = NodeSet(\nlabels=node.labels,\nmerge_keys=node.merge_property_keys\nif node.merge_property_keys\nelse list(node.keys()),\n)\nreturn self._nodeSets[node_type_fingerprint]\ndef _manifest_rel_from_cache(self, cached_relation: Relation):\nrel_set: RelationshipSet = self._get_or_create_relSet(cached_relation)\nrel_set.add_relationship(\nstart_node_properties=cached_relation.start_node,\nend_node_properties=cached_relation.end_node,\nproperties=cached_relation,\n)\ndef _get_or_create_relSet(self, relation: Relation) -&gt; RelationshipSet:\nrel_id = (\nfrozenset(relation.start_node.labels),\nfrozenset(relation.start_node.merge_property_keys),\nrelation.relation_type,\nfrozenset(relation.end_node.labels),\nfrozenset(relation.end_node.merge_property_keys),\n)\nif rel_id not in self._relSets:\nself._relSets[rel_id] = RelationshipSet(\nrel_type=relation.relation_type,\nstart_node_labels=relation.start_node.labels,\nend_node_labels=relation.end_node.labels,\nstart_node_properties=relation.start_node.merge_property_keys,\nend_node_properties=relation.end_node.merge_property_keys,\n)\nreturn self._relSets[rel_id]\ndef _flush_cache(self):\nself._run_transformations()\nfor node in self._node_cache:\nif not node.deleted:\nself._manifest_node_from_cache(node)\nfor rel in self._rel_cache:\nif not rel.deleted:\nself._manifest_rel_from_cache(rel)\nself._node_cache = []\nself._rel_cache = []\ndef _run_transformations(self):\nfor trans in self.node_transformators:\nfor node in self._node_cache:\ntrans._run_node_match_and_transform(node)\nfor trans in self.relation_transformators:\nfor rel in self._rel_cache:\ntrans._run_rel_match_and_transform(rel)\n</code></pre>"},{"location":"api/api_dict2graph/#dict2graph.dict2graph.Dict2graph.__init__","title":"<code>__init__(create_ids_for_empty_nodes=True, interpret_single_props_as_labels=True)</code>","text":"<p>Main class for dict2graph. Instance Dict2graph to get access to the API. Usage: <pre><code>from dict2graph import Dict2graph\nd2g = Dict2Graph()\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>create_ids_for_empty_nodes</code> <code>bool</code> <p>When input dicts results in empty 'hub' nodes, this will create artificially key properties based on the child data. The key will be deterministic . Defaults to True.</p> <code>True</code> <code>interpret_single_props_as_labels</code> <code>bool</code> <p>When having object with a single property like <code>{\"animal\":{\"name\":\"dog\"}}</code> <code>animal</code> will be interpreted as label. If set to false \"animal\" will result in an extra Node. Defaults to True.</p> <code>True</code> Source code in <code>dict2graph/dict2graph.py</code> <pre><code>def __init__(\nself,\ncreate_ids_for_empty_nodes: bool = True,\ninterpret_single_props_as_labels: bool = True,\n):\n\"\"\"Main class for dict2graph. Instance Dict2graph to get access to the API.\n    Usage:\n    ```python\n    from dict2graph import Dict2graph\n    d2g = Dict2Graph()\n    ```\n    Args:\n        create_ids_for_empty_nodes (bool, optional): When input dicts results in empty 'hub' nodes, this will create artificially key properties based on the child data. The key will be deterministic . Defaults to True.\n        interpret_single_props_as_labels (bool, optional): When having object with a single property like `{\"animal\":{\"name\":\"dog\"}}` `animal` will be interpreted as label. If set to false \"animal\" will result in an extra Node. Defaults to True.\n    \"\"\"\nself.create_ids_for_empty_nodes = create_ids_for_empty_nodes\n# Todo: \"interpret_single_props_as_labels\" should be a regualr NodeTransformer instead of a class param\nself.interpret_single_props_as_labels = interpret_single_props_as_labels\nself._node_cache: List[Node] = []\nself._rel_cache: List[Relation] = []\nself._nodeSets: Dict[Tuple, NodeSet] = {}\nself._relSets: Dict[Tuple, RelationshipSet] = {}\nself.node_transformators: List[_NodeTransformerBase] = []\nself.relation_transformators: List[_RelationTransformerBase] = []\n</code></pre>"},{"location":"api/api_dict2graph/#dict2graph.dict2graph.Dict2graph.add_transformation","title":"<code>add_transformation(transformator)</code>","text":"<p>Add a <code>Transformers</code> to the Dict2Graph instance. Transformers can re-model your graph befor writing it to a Neo4h database. usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nd2g = Dict2Graph()\nd2g.add_transformation(\nTransformer.match_node(\"article\").do(NodeTrans.OverrideLabel(\"book\"))\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>transformator</code> <code>Union[_NodeTransformerBase, _RelationTransformerBase, List[Union[_NodeTransformerBase, _RelationTransformerBase]]]</code> <p>A list or single instance of a Transformer</p> required Source code in <code>dict2graph/dict2graph.py</code> <pre><code>def add_transformation(\nself,\ntransformator: Union[\n_NodeTransformerBase,\n_RelationTransformerBase,\nList[Union[_NodeTransformerBase, _RelationTransformerBase]],\n],\n):\n\"\"\"Add a [`Transformers`](dict2graph/use_transformers.md) to the Dict2Graph instance.\n    Transformers can re-model your graph befor writing it to a Neo4h database.\n    usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    d2g = Dict2Graph()\n    d2g.add_transformation(\n        Transformer.match_node(\"article\").do(NodeTrans.OverrideLabel(\"book\"))\n    )\n    ```\n    Args:\n        transformator (Union[ _NodeTransformerBase, _RelationTransformerBase, List[Union[_NodeTransformerBase, _RelationTransformerBase]], ]): A list or single instance of a Transformer\n    \"\"\"\nif isinstance(transformator, list):\nfor trans in transformator:\nself.add_transformation(trans)\nif issubclass(transformator.__class__, _NodeTransformerBase) or (\nissubclass(\ntransformator.__class__,\n_NodeTransformerBase,\n)\nand issubclass(transformator.__class__, _RelationTransformerBase)\n):\nself.add_node_transformation(transformator)\nelif issubclass(transformator.__class__, _RelationTransformerBase):\nself.add_relation_transformation(transformator)\n</code></pre>"},{"location":"api/api_node/","title":"Node","text":""},{"location":"api/api_node/#dict2graph.Node","title":"<code>dict2graph.Node</code>","text":"<p>         Bases: <code>dict</code></p> <p>Represantation of a property-graph node</p> Source code in <code>dict2graph/node.py</code> <pre><code>class Node(dict):\n\"\"\"Represantation of a property-graph node\"\"\"\ndef __init__(\nself,\nlabels: List[str],\nsource_data: Union[Dict, List, str, int],\nparent_node: Node,\n**kwargs,\n):\nif isinstance(labels, str):\nlabels = [labels]\nself._labels: List[str] = labels\nself.parent_node: Node = parent_node\nself.source_data: Dict = source_data\nself._merge_property_keys: List[str] = None\nself.update(**kwargs)\nself._relations: List[Relation] = []\nself.is_list_list_hub: bool = False\nself.is_list_list_item: bool = False\nself.is_root_node: bool = False\nself.deleted = False\n@property\ndef id(self) -&gt; str:\n\"\"\"Deterministic identifier of the Node.\n        Will change if the nodes changes merge properties change.\n        The `id` is for internal use will not end up in the Neo4j graph.\n        Returns:\n            str: The id. A hex number string\n        \"\"\"\nif self.merge_property_keys and len(self.merge_property_keys) == 1:\nreturn self[self.merge_property_keys[0]]\nelif len(self.keys()) == 0:\nreturn None\nelse:\nreturn hashlib.md5(\nbytes(\njson.dumps([self[key] for key in self.merge_property_keys]),\n\"utf-8\",\n),\n).hexdigest()\n@property\ndef labels(self) -&gt; List[str]:\n\"\"\"All labels of the node as a list\n        Returns:\n            List[str]: Labels\n        \"\"\"\nreturn self._labels\n@labels.setter\ndef labels(self, val: List[str]):\nif isinstance(val, list):\nself._labels = val\nelse:\nraise ValueError(f\"Labels must be provided as list, got {val}\")\n@property\ndef primary_label(self) -&gt; str:\n\"\"\"The label to visually represent the node.\n        Returns:\n            str: the primary label as a string\n        \"\"\"\nreturn self._labels[0] if self.labels else None\n@primary_label.setter\ndef primary_label(self, val: str):\nif val in self._labels:\nself._labels.insert(0, self._labels.pop(self._labels.index(val)))\nelse:\nself._labels.insert(0, val)\n@property\ndef merge_property_keys(self) -&gt; List[str]:\n\"\"\"When merging to Neo4j instead of creating, these properties will be taken into account.\n        Similar to primary keys in the SQL World.\n        Defaults include all properties of the node.\n        Returns:\n            List[str]: The\n        \"\"\"\nreturn (\nself._merge_property_keys\nif self._merge_property_keys\nelse list(self.keys())\n)\n@merge_property_keys.setter\ndef merge_property_keys(self, primary_props: List[str]):\nself._merge_property_keys = primary_props\ndef get_hash(\nself,\ninclude_properties: List[str] = None,\ninclude_merge_properties: bool = True,\ninclude_other_properties: bool = True,\ninclude_parent_properties: bool = False,\ninclude_children_properties: bool = False,\ninclude_children_data: bool = False,\n) -&gt; str:\n\"\"\"Generate a deterministic hash of the node.\n        Optionaly this hahs can include data from child or parents to distinguish from nodes with equal properties.\n        Args:\n            include_properties (List[str], optional): A list of properties to include in the hash. Defaults to None.\n            include_merge_properties (bool, optional): Set True to also include merge properties. Defaults to True.\n            include_other_properties (bool, optional): Set True to also include non merge properties. Defaults to True.\n            include_parent_properties (bool, optional): Set True to also include merge properties of parent nodes. Defaults to False.\n            include_children_properties (bool, optional): Set True to also include merge properties of direct child nodes. Defaults to False.\n            include_children_data (bool, optional): Set True to also include all properties of the child tree. Defaults to False.\n        Returns:\n            str: A hex number string\n        \"\"\"\nif include_properties is None:\ninclude_properties = []\nhash_source_values = []\nif include_properties:\nhash_source_values.extend(\n[{key: val} for key, val in self.items() if key in include_properties]\n)\nif include_merge_properties:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.items()\nif key in self.merge_property_keys + include_properties\n]\n)\nif include_other_properties:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.items()\nif key not in self.merge_property_keys + include_properties\n]\n)\nif include_parent_properties and self.parent_node is not None:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.parent_node.items()\nif key not in self.parent_node.merge_property_keys\n]\n)\nif include_children_properties:\nfor child in self.child_nodes:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in child.items()\nif key not in child.merge_property_keys\n]\n)\nif include_children_data:\nfor child in self.child_nodes:\nhash_source_values.append(child.source_data)\nreturn hashlib.md5(\nbytes(\njson.dumps(hash_source_values),\n\"utf-8\",\n),\n).hexdigest()\n@property\ndef relations(self) -&gt; List[Relation]:\n\"\"\"All relationships a node is connected with\n        Returns:\n            List[Relation]: A list of relations\n        \"\"\"\nreturn self._relations\n@relations.setter\ndef relations(self, relations: List[Relation]):\nself._relations = [rel for rel in relations if not rel.deleted]\n@property\ndef outgoing_relations(self) -&gt; List[Relation]:\n\"\"\"All outgoing relationships a node is connected with\n        Returns:\n            List[Relation]: A list of relations\n        \"\"\"\nreturn [rel for rel in self.relations if rel.start_node == self]\n@property\ndef incoming_relations(self) -&gt; List[Relation]:\n\"\"\"All incoming relationships a node is connected with\n        Returns:\n            List[Relation]: A list of relations\n        \"\"\"\nreturn [rel for rel in self.relations if rel.end_node == self]\n@property\ndef child_nodes(self) -&gt; List[Node]:\n\"\"\"All nodes of outgoing relationshipsets\n        Returns:\n            List[Node]: A list of Nodes\n        \"\"\"\nreturn [rel.end_node for rel in self.outgoing_relations]\ndef __str__(self):\nreturn f\"({':'.join(self.labels)}{super().__str__()})\"\n</code></pre>"},{"location":"api/api_node/#dict2graph.node.Node.child_nodes","title":"<code>child_nodes: List[Node]</code>  <code>property</code>","text":"<p>All nodes of outgoing relationshipsets</p> <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[Node]: A list of Nodes</p>"},{"location":"api/api_node/#dict2graph.node.Node.id","title":"<code>id: str</code>  <code>property</code>","text":"<p>Deterministic identifier of the Node. Will change if the nodes changes merge properties change. The <code>id</code> is for internal use will not end up in the Neo4j graph.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The id. A hex number string</p>"},{"location":"api/api_node/#dict2graph.node.Node.incoming_relations","title":"<code>incoming_relations: List[Relation]</code>  <code>property</code>","text":"<p>All incoming relationships a node is connected with</p> <p>Returns:</p> Type Description <code>List[Relation]</code> <p>List[Relation]: A list of relations</p>"},{"location":"api/api_node/#dict2graph.node.Node.labels","title":"<code>labels: List[str]</code>  <code>writable</code> <code>property</code>","text":"<p>All labels of the node as a list</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Labels</p>"},{"location":"api/api_node/#dict2graph.node.Node.merge_property_keys","title":"<code>merge_property_keys: List[str]</code>  <code>writable</code> <code>property</code>","text":"<p>When merging to Neo4j instead of creating, these properties will be taken into account. Similar to primary keys in the SQL World.</p> <p>Defaults include all properties of the node.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The</p>"},{"location":"api/api_node/#dict2graph.node.Node.outgoing_relations","title":"<code>outgoing_relations: List[Relation]</code>  <code>property</code>","text":"<p>All outgoing relationships a node is connected with</p> <p>Returns:</p> Type Description <code>List[Relation]</code> <p>List[Relation]: A list of relations</p>"},{"location":"api/api_node/#dict2graph.node.Node.primary_label","title":"<code>primary_label: str</code>  <code>writable</code> <code>property</code>","text":"<p>The label to visually represent the node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the primary label as a string</p>"},{"location":"api/api_node/#dict2graph.node.Node.relations","title":"<code>relations: List[Relation]</code>  <code>writable</code> <code>property</code>","text":"<p>All relationships a node is connected with</p> <p>Returns:</p> Type Description <code>List[Relation]</code> <p>List[Relation]: A list of relations</p>"},{"location":"api/api_node/#dict2graph.node.Node.get_hash","title":"<code>get_hash(include_properties=None, include_merge_properties=True, include_other_properties=True, include_parent_properties=False, include_children_properties=False, include_children_data=False)</code>","text":"<p>Generate a deterministic hash of the node. Optionaly this hahs can include data from child or parents to distinguish from nodes with equal properties.</p> <p>Parameters:</p> Name Type Description Default <code>include_properties</code> <code>List[str]</code> <p>A list of properties to include in the hash. Defaults to None.</p> <code>None</code> <code>include_merge_properties</code> <code>bool</code> <p>Set True to also include merge properties. Defaults to True.</p> <code>True</code> <code>include_other_properties</code> <code>bool</code> <p>Set True to also include non merge properties. Defaults to True.</p> <code>True</code> <code>include_parent_properties</code> <code>bool</code> <p>Set True to also include merge properties of parent nodes. Defaults to False.</p> <code>False</code> <code>include_children_properties</code> <code>bool</code> <p>Set True to also include merge properties of direct child nodes. Defaults to False.</p> <code>False</code> <code>include_children_data</code> <code>bool</code> <p>Set True to also include all properties of the child tree. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A hex number string</p> Source code in <code>dict2graph/node.py</code> <pre><code>def get_hash(\nself,\ninclude_properties: List[str] = None,\ninclude_merge_properties: bool = True,\ninclude_other_properties: bool = True,\ninclude_parent_properties: bool = False,\ninclude_children_properties: bool = False,\ninclude_children_data: bool = False,\n) -&gt; str:\n\"\"\"Generate a deterministic hash of the node.\n    Optionaly this hahs can include data from child or parents to distinguish from nodes with equal properties.\n    Args:\n        include_properties (List[str], optional): A list of properties to include in the hash. Defaults to None.\n        include_merge_properties (bool, optional): Set True to also include merge properties. Defaults to True.\n        include_other_properties (bool, optional): Set True to also include non merge properties. Defaults to True.\n        include_parent_properties (bool, optional): Set True to also include merge properties of parent nodes. Defaults to False.\n        include_children_properties (bool, optional): Set True to also include merge properties of direct child nodes. Defaults to False.\n        include_children_data (bool, optional): Set True to also include all properties of the child tree. Defaults to False.\n    Returns:\n        str: A hex number string\n    \"\"\"\nif include_properties is None:\ninclude_properties = []\nhash_source_values = []\nif include_properties:\nhash_source_values.extend(\n[{key: val} for key, val in self.items() if key in include_properties]\n)\nif include_merge_properties:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.items()\nif key in self.merge_property_keys + include_properties\n]\n)\nif include_other_properties:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.items()\nif key not in self.merge_property_keys + include_properties\n]\n)\nif include_parent_properties and self.parent_node is not None:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.parent_node.items()\nif key not in self.parent_node.merge_property_keys\n]\n)\nif include_children_properties:\nfor child in self.child_nodes:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in child.items()\nif key not in child.merge_property_keys\n]\n)\nif include_children_data:\nfor child in self.child_nodes:\nhash_source_values.append(child.source_data)\nreturn hashlib.md5(\nbytes(\njson.dumps(hash_source_values),\n\"utf-8\",\n),\n).hexdigest()\n</code></pre>"},{"location":"api/api_relation/","title":"Relation","text":""},{"location":"api/api_relation/#dict2graph.Relation","title":"<code>dict2graph.Relation</code>","text":"<p>         Bases: <code>dict</code></p> <p>Represantation of a property-graph relationship</p> Source code in <code>dict2graph/relation.py</code> <pre><code>class Relation(dict):\n\"\"\"Represantation of a property-graph relationship\"\"\"\ndef __init__(\nself, start_node: Node, end_node: Node, relation_type: str = None, **kwargs\n):\n\"\"\"Create a new relationship\n        Args:\n            start_node (Node): The node from which the relationship will start\n            end_node (Node): The node to which the relationship will go to\n            relation_type (str, optional): The name if the relation. Defaults to None.\n            **kwargs (Any, optional): Any further properties of this relationship. Defaults to None.\n        \"\"\"\nself._relation_type = relation_type\nself._start_node = None\nself._end_node = None\nself.start_node = start_node\nself.end_node = end_node\nself._origin_relation_type: str = relation_type\nself.deleted = False\nself.update(**kwargs)\n@property\ndef relation_type(self) -&gt; str:\n\"\"\"The name of the relationship.\n        As in [Neo4j Relation Type](https://neo4j.com/docs/getting-started/current/appendix/graphdb-concepts/#graphdb-relationship-type)\n        Defaults to a string with following structure:\n        `&lt;start node first label&gt;_HAS_&lt;end_node_first_label&gt;`\n        Returns:\n            str: The relationship type as str\n        \"\"\"\nif self._relation_type:\nreturn self._relation_type\nelif self.start_node is not None and self.end_node is not None:\nif (\nself.start_node.is_list_list_hub\n# and not self.start_node.is_root_node\n):\nreturn f\"{self.start_node.primary_label}_LIST_HAS_{self.end_node.primary_label}\"\nelse:\nreturn (\nf\"{self.start_node.primary_label}_HAS_{self.end_node.primary_label}\"\n)\nelse:\nreturn \"NON_NAMED_REL\"\n@relation_type.setter\ndef relation_type(self, value: str) -&gt; str:\nself._relation_type = value\n@property\ndef start_node(self) -&gt; Node:\n\"\"\"The node from which the relationship is originating\n        Returns:\n            Node: The start node as a [Dict2Graph.Node](/api/api_node) instance\n        \"\"\"\nreturn self._start_node\n@start_node.setter\ndef start_node(self, node: Node):\nif self._start_node:\n# relation changed. we need to remove the relation form the old node\nself._start_node.relations.remove(self)\nnode.relations.append(self)\nself._start_node = node\n@property\ndef end_node(self) -&gt; Node:\n\"\"\"The target node of the relationship\n        Returns:\n            Node: The end node as a [Dict2Graph.Node](/api/api_node) instance\n        \"\"\"\nreturn self._end_node\n@end_node.setter\ndef end_node(self, node: Node):\nif self._end_node:\nself._end_node.relations.remove(self)\nnode.relations.append(self)\nself._end_node = node\ndef __str__(self):\nreturn f\"{self.start_node}-[{self.relation_type}]-&gt;({self.end_node})\"\n</code></pre>"},{"location":"api/api_relation/#dict2graph.relation.Relation.end_node","title":"<code>end_node: Node</code>  <code>writable</code> <code>property</code>","text":"<p>The target node of the relationship</p> <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The end node as a Dict2Graph.Node instance</p>"},{"location":"api/api_relation/#dict2graph.relation.Relation.relation_type","title":"<code>relation_type: str</code>  <code>writable</code> <code>property</code>","text":"<p>The name of the relationship. As in Neo4j Relation Type</p> <p>Defaults to a string with following structure:</p> <p><code>&lt;start node first label&gt;_HAS_&lt;end_node_first_label&gt;</code></p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The relationship type as str</p>"},{"location":"api/api_relation/#dict2graph.relation.Relation.start_node","title":"<code>start_node: Node</code>  <code>writable</code> <code>property</code>","text":"<p>The node from which the relationship is originating</p> <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The start node as a Dict2Graph.Node instance</p>"},{"location":"api/api_relation/#dict2graph.relation.Relation.__init__","title":"<code>__init__(start_node, end_node, relation_type=None, **kwargs)</code>","text":"<p>Create a new relationship</p> <p>Parameters:</p> Name Type Description Default <code>start_node</code> <code>Node</code> <p>The node from which the relationship will start</p> required <code>end_node</code> <code>Node</code> <p>The node to which the relationship will go to</p> required <code>relation_type</code> <code>str</code> <p>The name if the relation. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any further properties of this relationship. Defaults to None.</p> <code>{}</code> Source code in <code>dict2graph/relation.py</code> <pre><code>def __init__(\nself, start_node: Node, end_node: Node, relation_type: str = None, **kwargs\n):\n\"\"\"Create a new relationship\n    Args:\n        start_node (Node): The node from which the relationship will start\n        end_node (Node): The node to which the relationship will go to\n        relation_type (str, optional): The name if the relation. Defaults to None.\n        **kwargs (Any, optional): Any further properties of this relationship. Defaults to None.\n    \"\"\"\nself._relation_type = relation_type\nself._start_node = None\nself._end_node = None\nself.start_node = start_node\nself.end_node = end_node\nself._origin_relation_type: str = relation_type\nself.deleted = False\nself.update(**kwargs)\n</code></pre>"},{"location":"api/api_transformer/","title":"Transformer","text":""},{"location":"api/api_transformer/#dict2graph.Transformer","title":"<code>dict2graph.Transformer</code>","text":"Source code in <code>dict2graph/transformers/_base.py</code> <pre><code>class Transformer:\nclass NodeTransformerMatcher:\ndef _set_node_matcher(\nself,\nlabel_match: Union[str, List[str], AnyLabel],\nhas_one_label_of: List[str] = None,\nhas_none_label_of: List[str] = None,\n):\nif isinstance(label_match, str):\nlabel_match = [label_match]\nself.label_match: Union[List[str], AnyLabel] = label_match\nself.has_one_label_of = has_one_label_of\nself.has_none_label_of = has_none_label_of\ndef _match(self, node: Node) -&gt; bool:\nif self.has_none_label_of is not None and not set(\nself.has_none_label_of\n).isdisjoint(node.labels):\nreturn False\nif self.has_one_label_of is not None and not set(\nself.has_one_label_of\n).isdisjoint(set(node.labels)):\nreturn True\nif self.label_match == AnyLabel or set(self.label_match).issubset(\nset(node.labels)\n):\nreturn True\nreturn False\ndef do(self, transform: _NodeTransformerBase) -&gt; _NodeTransformerBase:\ntransform._set_matcher(self)\nreturn transform\nclass RelTransformerMatcher:\ndef _set_rel_matcher(\nself,\nrelation_type_match: Union[str, List[str], AnyRelation],\nrelation_type_is_not_in: List[str],\n):\nif isinstance(relation_type_match, str):\nself.relation_type_match = [relation_type_match]\nelse:\nself.relation_type_match = relation_type_match\nself.relation_type_match = relation_type_match\nif relation_type_is_not_in:\nself.relation_type_is_not_in = relation_type_is_not_in\nelse:\nself.relation_type_is_not_in = []\ndef _match(self, rel: Relation) -&gt; bool:\nif (\nself.relation_type_match in [None, AnyRelation]\nor rel.relation_type in self.relation_type_match\n) and rel.relation_type not in self.relation_type_is_not_in:\nreturn True\nreturn False\ndef do(self, transform: _RelationTransformerBase) -&gt; _RelationTransformerBase:\ntransform._set_matcher(self)\nreturn transform\n@classmethod\ndef match_node(\ncls,\nhas_labels: Union[str, List[str], AnyLabel] = AnyLabel,\nhas_one_label_of: List[str] = None,\nhas_none_label_of: List[str] = None,\n) -&gt; NodeTransformerMatcher:\n\"\"\"Match nodes to apply tranformers\n        Args:\n            has_labels (Union[str, List[str], AnyLabel], optional): _description_. Defaults to AnyLabel.\n            has_one_label_of (List[str], optional): _description_. Defaults to None.\n            has_none_label_of (List[str], optional): _description_. Defaults to None.\n        Returns:\n            NodeTransformerMatcher: _description_\n        \"\"\"\ntm = Transformer.NodeTransformerMatcher()\ntm._set_node_matcher(\nlabel_match=has_labels,\nhas_one_label_of=has_one_label_of,\nhas_none_label_of=has_none_label_of,\n)\nreturn tm\n@classmethod\ndef match_rel(\ncls,\nrelation_type: Union[str, List[str], AnyRelation] = AnyRelation,\nrelation_type_is_not_in: List[str] = None,\n) -&gt; RelTransformerMatcher:\n\"\"\"Match relationships to apply tranformers\n        Args:\n            relation_name (Union[str, AnyRelation], optional): A relation type as string or mulitple relation types as list of string. Defaults to AnyRelation.\n        Returns:\n            RelTransformerMatcher: _description_\n        \"\"\"\ntm = Transformer.RelTransformerMatcher()\ntm._set_rel_matcher(\nrelation_type_match=relation_type,\nrelation_type_is_not_in=relation_type_is_not_in,\n)\nreturn tm\n</code></pre>"},{"location":"api/api_transformer/#dict2graph.transformers._base.Transformer.match_node","title":"<code>match_node(has_labels=AnyLabel, has_one_label_of=None, has_none_label_of=None)</code>  <code>classmethod</code>","text":"<p>Match nodes to apply tranformers</p> <p>Parameters:</p> Name Type Description Default <code>has_labels</code> <code>Union[str, List[str], AnyLabel]</code> <p>description. Defaults to AnyLabel.</p> <code>AnyLabel</code> <code>has_one_label_of</code> <code>List[str]</code> <p>description. Defaults to None.</p> <code>None</code> <code>has_none_label_of</code> <code>List[str]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NodeTransformerMatcher</code> <code>NodeTransformerMatcher</code> <p>description</p> Source code in <code>dict2graph/transformers/_base.py</code> <pre><code>@classmethod\ndef match_node(\ncls,\nhas_labels: Union[str, List[str], AnyLabel] = AnyLabel,\nhas_one_label_of: List[str] = None,\nhas_none_label_of: List[str] = None,\n) -&gt; NodeTransformerMatcher:\n\"\"\"Match nodes to apply tranformers\n    Args:\n        has_labels (Union[str, List[str], AnyLabel], optional): _description_. Defaults to AnyLabel.\n        has_one_label_of (List[str], optional): _description_. Defaults to None.\n        has_none_label_of (List[str], optional): _description_. Defaults to None.\n    Returns:\n        NodeTransformerMatcher: _description_\n    \"\"\"\ntm = Transformer.NodeTransformerMatcher()\ntm._set_node_matcher(\nlabel_match=has_labels,\nhas_one_label_of=has_one_label_of,\nhas_none_label_of=has_none_label_of,\n)\nreturn tm\n</code></pre>"},{"location":"api/api_transformer/#dict2graph.transformers._base.Transformer.match_rel","title":"<code>match_rel(relation_type=AnyRelation, relation_type_is_not_in=None)</code>  <code>classmethod</code>","text":"<p>Match relationships to apply tranformers</p> <p>Parameters:</p> Name Type Description Default <code>relation_name</code> <code>Union[str, AnyRelation]</code> <p>A relation type as string or mulitple relation types as list of string. Defaults to AnyRelation.</p> required <p>Returns:</p> Name Type Description <code>RelTransformerMatcher</code> <code>RelTransformerMatcher</code> <p>description</p> Source code in <code>dict2graph/transformers/_base.py</code> <pre><code>@classmethod\ndef match_rel(\ncls,\nrelation_type: Union[str, List[str], AnyRelation] = AnyRelation,\nrelation_type_is_not_in: List[str] = None,\n) -&gt; RelTransformerMatcher:\n\"\"\"Match relationships to apply tranformers\n    Args:\n        relation_name (Union[str, AnyRelation], optional): A relation type as string or mulitple relation types as list of string. Defaults to AnyRelation.\n    Returns:\n        RelTransformerMatcher: _description_\n    \"\"\"\ntm = Transformer.RelTransformerMatcher()\ntm._set_rel_matcher(\nrelation_type_match=relation_type,\nrelation_type_is_not_in=relation_type_is_not_in,\n)\nreturn tm\n</code></pre>"}]}