{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Start","text":""},{"location":"#dict2graph","title":"Dict2graph","text":""},{"location":"#tb27012023-rewrite-in-progress-please-do-not-use-yet","title":"\ud83c\udfd7\ufe0f TB,27.01.2023: REWRITE IN PROGRESS. Please do not use yet!","text":"<p>Transfer (json compatible) Python dicts into a Neo4j graph database. dict2graph also comes with some powerful data transform capabilities.</p> <p>Maintainer: tim.bleimehl@dzd-ev.de</p> <p>Licence: MIT</p> <p>public issue tracker: https://github.com/dzd-ev/dict2graph-docs/issues</p> <p>user docs: https://dzd-ev.github.io/dict2graph-docs/</p> <p>source code: https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph</p> <p>important upstream modules:</p> <ul> <li>https://github.com/kaiserpreusse/graphio </li> <li>https://github.com/neo4j/neo4j-python-driver </li> <li>https://github.com/py2neo-org/py2neo </li> </ul> <p>Content:</p> <ul> <li>Dict2graph</li> <li>\ud83c\udfd7\ufe0f TB,27.01.2023: REWRITE IN PROGRESS. Please do not use yet!</li> <li>Install</li> <li>What is dict2graph</li> <li>Recommended workflow</li> <li>What dict2graph is not</li> <li>py2neo depcrecation warning</li> <li>Basic Usage Example</li> <li>Load a dict<ul> <li>Transform the model</li> </ul> </li> </ul>"},{"location":"#install","title":"Install","text":"<p>at the moment if dev:</p> <p><code>pip3 install git+https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph.git@V3</code></p> <p>Later will be:</p> <p><code>pip3 install dict2graph</code></p>"},{"location":"#what-is-dict2graph","title":"What is dict2graph","text":"<p>With dict2graph you can transfer python dicts into a neo4j graph out of the box. And if you are not happy with the structure of the result, dict2graph comes with a bunch of, transformation tools, which are easy to apply to your model.</p>"},{"location":"#recommended-workflow","title":"Recommended workflow","text":"<p>The recommended workflow is:</p> <ul> <li>Load your dict (or a sample of your larger datasets) as it is, with dict2graph into a neo4j test instance</li> <li>Inspect the result in neo4j</li> <li>Add dict2graph-transformators to shape your resulting graph model</li> <li>Wipe your neo4j test instance</li> <li>Repeat the work flow with the changed dict2graph-transformators until your happy with the result</li> </ul>"},{"location":"#what-dict2graph-is-not","title":"What dict2graph is not","text":"<p>dict2graph can not be used for de-/serializing your dict into a graph database. There is no <code>graph2dict</code> functionality (nore is it planned to have one). Your data/dict will be transformed to be more suitable in a graph represantation. On the way, certain informations can be lost. Reproducing the exact same dict from the graph is not possible in many cases.</p>"},{"location":"#py2neo-depcrecation-warning","title":"py2neo depcrecation warning","text":"<p>In past versions of <code>dict2graph</code>, the awesome <code>py2neo</code> library was the only way to connect to a Neo4j instance. But (sadly) this lib is in a low-maintanance mode. For now it is still supported but marked as deprecated. We recommend to switch to the official Neo4j Python Driver. </p>"},{"location":"#basic-usage-example","title":"Basic Usage Example","text":"<p>With formalities out of the way, lets have some simple examples how dict2graph works...</p>"},{"location":"#load-a-dict","title":"Load a dict","text":"<pre><code>from dict2graph import Dict2graph\nfrom neo4j import GraphDatabase\n# connect to our neo4j database\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n# lets create a small random  dict\ndic = {\n\"Action\": {\n\"id\": 1,\n\"target\": \"El Oued\",\n\"Entities\": [{\"id\": \"Isabelle Eberhardt\"}, {\"id\": \"Slim\u00e8ne Ehnni\"}],\n}\n}\n# create a dict2graph instance, \n# parse the dict \n# and load it into our neo4j instance.\nDict2graph().parse(dic).create(NEO4J_DRIVER)\n</code></pre> <p>This will result in following graph:</p> <p></p>"},{"location":"#transform-the-model","title":"Transform the model","text":"<p>We now have loaded the dict data into a Neo4j Graph. But usally we dont need stuff like explicit <code>list</code>s in a graph. Also it is common to uppercase relationship types and capitalize labels.</p> <p>So we need to make some adjustments to improve the graph represenation of the dict. This is where <code>dict2graph.Transformer</code>s come into play.</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans, RelTrans\nfrom py2neo import Graph\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata = {\n\"Action\": {\n\"id\": 1,\n\"target\": \"El Oued\",\n\"Entities\": [{\"id\": \"Isabelle Eberhardt\"}, {\"id\": \"Slim\u00e8ne Ehnni\"}],\n}\n}\nd2g = Dict2graph()\nd2g.add_transformation(\n[\nTransformer.match_nodes().do(NodeTrans.CapitalizeLabels()),\nTransformer.match_rels().do(RelTrans.UppercaseRelationType()),\nTransformer.match_nodes().do(NodeTrans.PopListHubNodes()),\n]\n)\nd2g.parse(data)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>Now that looks more like a graph we are used to, isn't it?</p> <p></p> <p>There are a lot of more powerful <code>Transformator</code>s and you can even make your own \ud83d\ude80!  Have a deeper look into the docs to learn more how Transformators work.</p>"},{"location":"DOCS_README/","title":"dict2graph Docs Pages Repo","text":"<p>Maintainer: tim.bleimehl at dzd-ev.de</p> <p>this is the repository for the dict2graph documentation website/github pages.</p> <p>dict2graph is a Python tool to transfer json data into a Neo4j graph</p> <p>Visit https://dzd-ev.github.io/dict2graph-docs/ to learn more about dict2graph. Or visit https://git.connect.dzd-ev.de/dzdpythonmodules/dict2graph to browse the dict2graph source code.</p>"},{"location":"basics/","title":"Basic concepts of dict2graph","text":"<p>To get a grasp how dict2graph is working lets have a look at a simple example</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans, RelTrans\nfrom neo4j import GraphDatabase, Driver\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"affiliation\": {\"name\": \"Du\u00e1l\u00e1\"},\n}\n}\nd2g = Dict2graph()\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>This will create a graph that looks like</p> <p></p>"},{"location":"basics/#generated-labels","title":"Generated labels","text":"<p>You can see dict2graph interpreted the dict key <code>person</code> as the objects label. Same for <code>affiliation</code>. </p> <p>Basic types like strings, integers, boolean and so on will be interpreted as property.</p>"},{"location":"basics/#when-creating-is-not-enough","title":"When creating is not enough","text":"<p>Lets have example with two datasets.</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans, RelTrans\nfrom neo4j import GraphDatabase, Driver\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata_1 = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"affiliation\": {\"name\": \"Du\u00e1l\u00e1\"},\n}\n}\ndata_2 = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"mission\": {\"name\": \"resistance leader\"},\n}\n}\nd2g = Dict2graph()\nd2g.parse(data_1)\nd2g.parse(data_2)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>This results in a pretty unintuitiv graph:</p> <p></p> <p>We would expect two node pairs, each with one relationship. Something like:</p> <p></p> <p>But what we get is are 4 relationships. Why is that?  </p> <p>dict2graph creates relationship targets (start node, end node) based on the target nodes labels and properties. So if we have a node that looks equal to another they both will end up as a relatioship target, even we only wanted to relate one of them.</p> <p>You can workaround that by creating a custom key property. More on that later in the Chapter <code>dict2graph.Transformers</code>.</p>"},{"location":"basics/#merging","title":"Merging","text":"<p>In our case it would make sense to just merge equal nodes. We can be pretty sure, in our dataset, that <code>Rudolf</code> from dataset 1 is the same as <code>Rudolf</code> from dataset 2.</p> <p>So lets do that:</p> <p><pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans, RelTrans\nfrom neo4j import GraphDatabase, Driver\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata_1 = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"affiliation\": {\"name\": \"Du\u00e1l\u00e1\"},\n}\n}\ndata_2 = {\n\"person\": {\n\"firstname\": \"Rudolf\",\n\"lastname\": \"Manga Bell\",\n\"age\": 41,\n\"mission\": {\"name\": \"resistance leader\"},\n}\n}\nd2g = Dict2graph()\nd2g.parse(data_1)\nd2g.parse(data_2)\nd2g.merge(NEO4J_DRIVER)\n</code></pre> </p> <p>That looks neat, doesn't it? We merged our two dataset in one graph and connected the informations. That what graphs are for in the first place \ud83d\ude80</p>"},{"location":"hubbing/","title":"Hubbing","text":"<p>This chapter explains the concept of hubbing used in the python modules dict2graph. More precise, it is used in the node transformer <code>CreateHubbing</code></p>"},{"location":"hubbing/#the-problem","title":"The Problem","text":"<p>When merging multiple datasets, the connection from origin parent to child nodes can get lost. </p> <p>Lets have an example with two datasets that will be merged:</p> <p>Dataset 1: <pre><code>{\n\"article\": {\n\"title\": \"Blood money: Bayer's inventory of HIV-contaminated blood products and third world hemophiliacs\",\n\"author\": {\n\"name\": \"Leemon McHenry\",\n\"affiliation\": {\"name\": \"Department of Philosophy, California State University\"},\n},\n},\n}\n</code></pre></p> <p>Dataset 2:</p> <pre><code>{\n\"article\": {\n\"title\": \"Conflicted medical journals and the failure of trust\",\n\"author\": {\n\"name\": \"Leemon McHenry\",\n\"affiliation\": {\"name\": \"Discipline of Psychiatry, University of Adelaide\"},\n},\n},\n}\n</code></pre> <p>We have two different articles from the same author. The author contributed to both articles with different affiliations in the background.</p> <p>Both datasets, each as a graph imported with dict2graph, will look like this.</p> Articletitle:Blood Money...Authorname:Leemon McHenryAffiliationname:Department of Philosophy, California State University Articletitle:Conflicted medical...Authorname:Leemon McHenryAffiliationname:Discipline of Psychiatry, University of Adelaide <p>When we try to merge matching nodes together, we will have the following result:</p> <p>Articletitle:Conflicted medical...Authorname:Leemon McHenryAffiliationname:Discipline of Psychiatry, University of AdelaideAffiliationname:Department of Philosophy, California State UniversityArticletitle:Blood money...</p> <p>Now can you tell which article was released under which affiliation? Me neither.</p> <p>The information got lost, when we merged the two datasets.</p> <p>There are multiple solutions to this problem. Dict2graph solves this by letting you create new inbetween nodes:</p>"},{"location":"hubbing/#hubbing_1","title":"Hubbing","text":"<p>With dict2graph you can create \"hubs\". Hubbing will result in one or multiple new nodes that preserve the child parent relation while letting you merge equal nodes.</p> <p>In our example we will label the hubs with <code>Contribution</code>. The result will look like this:</p> <p>Articletitle:Conflicted medical...Authorname:Leemon McHenryAffiliationname:Department of Philosophy, California State UniversityAffiliationname:Department of Philosophy, California State UniversityArticletitle:Blood money...ContributionContribution</p> <p>Here we can still attribute the article to the affiliation without having author duplicates. But how did we get there. Lets take a deep dive:</p>"},{"location":"hubbing/#the-details","title":"The details","text":"<p>As a starting point we want to establish some vocabulary that is used internaly in dict2graph.</p>"},{"location":"hubbing/#vocabulary","title":"Vocabulary","text":"<p>To be able to define hubs with dict2graph, we need to point on specific node classes in a node chain. Lets name these:</p> <p></p>"},{"location":"hubbing/#hub-idenitity","title":"Hub idenitity","text":"<p>When trying to create hubs like in the above shown example another problem will occure:</p> <p>If we want to merge all our nodes that have the same values and properties, our hubs would merge as well. They need some kind of primary key to be unique. One solution would be create a random id for each hub. That would work in our example. </p> <p>But imagen, at a later stage, we want to merge another dataset:</p> <p>Dataset 3</p> <pre><code>{\n\"article\": {\n\"title\": \"Blood money: Bayer's inventory of HIV-contaminated blood products and third world hemophiliacs\",\n\"author\": {\n\"name\": \"Mellad Khoshnood\",\n\"affiliation\": {\"name\": \"Department of Philosophy, California State University\"},\n},\n},\n}\n</code></pre> <p>We have another another author for one our existing articles. Lets merge it:</p> <p>Articletitle:Conflicted medical...Authorname:Leemon McHenryAffiliationname:Department of Philosophy, California State UniversityAffiliationname:Department of Philosophy, California State UniversityArticletitle:Blood money...ContributiContributionContributionAuthorname:Mellad Khoshnood</p> <p>We have a new hub and with new relations. This less efficient compared to the most simple solution; connection everything directly (In our example an extra article-&gt;affiliation relation)</p> <p>But what if we create a primary key, for the hub, based on the egde nodes only?</p> <p>We could md5-hash the primary keys from <code>Article</code> and <code>Affiliation</code> and use this as the primary key for our hub.</p> <p></p> <p>With this approach the hubs for Dataset 2 and Dataset 3 should have the same primary key. Lets have a look at the result:</p> <p>Articletitle:Conflicted medical...Authorname:Leemon McHenryAffiliationname:Department of Philosophy, California State UniversityAffiliationname:Department of Philosophy, California State UniversityArticletitle:Blood money...Contributionid:226e6869...Contributionid:e67516....Authorname:Mellad Khoshnood</p> <p>This look neat doesn't it? This approach is fairly scalable, even with many authors, affiliations and articles in a dense graph.</p> <p>In dict2graph this we call this the \"egde merge mode\". As an alternative there is the \"lead merge mode\". In this case we build the hub id from lead nodes.</p> <p>The \"lead merge mode\" could be practible if the data comes in a structure like this:</p> <p>Dataset 4: <pre><code>{\n\"article\": {\n\"title\": \"Blood money: Bayer's inventory of HIV-contaminated blood products and third world hemophiliacs\",\n\"originator\": {\n\"affiliation\": \"Department of Philosophy, California State University\",\n\"author\": {\n\"name\": \"Leemon McHenry\",\n},\n},\n},\n}\n</code></pre></p> <p>With dict2graph this would result in a graph roughly looking like this:</p> <p>Authorname:Leemon McHenryAffiliationname:Department of Philosophy, California State UniversityArticletitle:Blood money...</p> <p>Almost the same; we need to build the hubs id (again) from <code>Article</code>and <code>Affiliation</code>. but in this case they are the leading nodes. So would operate in the so called \"lead merge mode\". You get the idea.</p>"},{"location":"hubbing/#nuff-said-lets-code","title":"'Nuff said. Let's code!","text":"<p>Lets apply our knowledge with the help of dict2graph now:</p> <p>Lets start with the baseline:</p> <pre><code>from dict2graph import Dict2graph\nfrom neo4j import GraphDatabase\nDRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g = Dict2graph()\ndataset_1 = {\n\"article\": {\n\"title\": \"Blood money: Bayer's inventory of HIV-contaminated blood products and third world hemophiliacs\",\n\"author\": {\n\"name\": \"Leemon McHenry\",\n\"affiliation\": {\n\"name\": \"Department of Philosophy, California State University\"\n},\n},\n},\n}\nd2g.parse(dataset_1)\ndataset_2 = {\n\"article\": {\n\"title\": \"Conflicted medical journals and the failure of trust\",\n\"author\": {\n\"name\": \"Leemon McHenry\",\n\"affiliation\": {\n\"name\": \"Discipline of Psychiatry, University of Adelaide\"\n},\n},\n},\n}\nd2g.parse(dataset_2)\nd2g.merge(DRIVER)\n</code></pre> <p>Lets have a look in Neo4j to inspect the result:</p> <p></p> <p>As expected. Looks nice but the information \"under which <code>affiliation</code> contributed the <code>author</code> to a certain <code>article</code>\" is lost.</p> <p>Lets fix that with a hub. We use <code>Dict2Graph.NodeTrans.CreateHubbing</code> for that.</p> <p>Lets summarize what we need to know to create a hub:</p> <ul> <li>We need to define a chain of nodes with:</li> <li>a start node</li> <li>two or more follow nodes</li> <li>two edge nodes</li> <li>Optional we can label the new hub node</li> </ul> <p>Lest do it: (We assume a fresh/wiped database) <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nDRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g = Dict2graph()\n# we define the start node by matching it with dict2graph\ntransformer = Transformer.match_nodes(\"article\").do(\n# apply the hubbing-transformer\nNodeTrans.CreateHubbing(\n# define the node chain by defining the follow node labels\nfollow_nodes_labels=[\"author\", \"affiliation\"],\n# define the merge mode\nmerge_mode=\"edge\",\n# give the hub node one or more labels\nhub_labels=[\"Contribution\"],\n)\n)\n# Add the transformator the tranformator stack of our Dict2graph instance\nd2g.add_transformation(transformer)\ndataset_1 = {\n\"article\": {\n\"title\": \"Blood money: Bayer's inventory of HIV-contaminated blood products and third world hemophiliacs\",\n\"author\": {\n\"name\": \"Leemon McHenry\",\n\"affiliation\": {\n\"name\": \"Department of Philosophy, California State University\"\n},\n},\n},\n}\nd2g.parse(dataset_1)\ndataset_2 = {\n\"article\": {\n\"title\": \"Conflicted medical journals and the failure of trust\",\n\"author\": {\n\"name\": \"Leemon McHenry\",\n\"affiliation\": {\n\"name\": \"Discipline of Psychiatry, University of Adelaide\"\n},\n},\n},\n}\nd2g.parse(dataset_2)\nd2g.merge(DRIVER)\n</code></pre></p> <p>Lets inspect the result:</p> <p></p> <p>Nice \ud83d\ude80 </p> <p>Lets add our third dataset to prove our theoretical foundations:</p> <p>(We assume a fresh/wiped database again) <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nDRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g = Dict2graph()\n# we define the start node by matching it with dict2graph\ntransformer = Transformer.match_nodes(\"article\").do(\n# apply the hubbing-transformer\nNodeTrans.CreateHubbing(\n# define the node chain by defining the follow node labels\nfollow_nodes_labels=[\"author\", \"affiliation\"],\n# define the merge mode\nmerge_mode=\"edge\",\n# give the hub node one or more labels\nhub_labels=[\"Contribution\"],\n)\n)\n# Add the transformator the tranformator stack of our Dict2graph instance\nd2g.add_transformation(transformer)\ndataset_1 = {\n\"article\": {\n\"title\": \"Blood money: Bayer's inventory of HIV-contaminated blood products and third world hemophiliacs\",\n\"author\": {\n\"name\": \"Leemon McHenry\",\n\"affiliation\": {\n\"name\": \"Department of Philosophy, California State University\"\n},\n},\n},\n}\nd2g.parse(dataset_1)\ndataset_2 = {\n\"article\": {\n\"title\": \"Conflicted medical journals and the failure of trust\",\n\"author\": {\n\"name\": \"Leemon McHenry\",\n\"affiliation\": {\n\"name\": \"Discipline of Psychiatry, University of Adelaide\"\n},\n},\n},\n}\nd2g.parse(dataset_2)\ndataaset_3 = {\n\"article\": {\n\"title\": \"Blood money: Bayer's inventory of HIV-contaminated blood products and third world hemophiliacs\",\n\"author\": {\n\"name\": \"Mellad Khoshnood\",\n\"affiliation\": {\"name\": \"Department of Philosophy, California State University\"},\n},\n},\n}\nd2g.parse(dataaset_3)\nd2g.merge(DRIVER)\n</code></pre></p> <p>And again, lets have a look in our database:</p> <p></p> <p>Oh, don't we love it when a plan comes together!</p> <p>All <code>articles</code>,<code>affiliations</code> and <code>authors</code> connected as efficient as it can get! And only a handfull extra lines of code (which would be unformated just one line of code).</p> <p>\ud83c\udf96\ufe0f Achievement unlocked  You are now a Hubber!</p>"},{"location":"list_generic_transformer/","title":"Generic Transformers","text":"<p>dict2graph comes with a lot of predefined transformators. For a basic concepts of a dict2Graph transformators have a look at How to use Transformators</p>"},{"location":"list_generic_transformer/#generic-transformators-list","title":"Generic Transformators List","text":"<p>This is a list if transformators that can be applied to nodes and relationships</p>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.AddProperty","title":"<code>AddProperty</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code>, <code>_NodeTransformerBase</code></p> <p>Add a property to a node Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(NodeTrans.AddProperty({\"my_new_prop_key\":\"my_new_prop_value_1111\"}))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{name:'Camina',my_new_prop_key:\"my_new_prop_value_1111\"})</code>.</p> Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>class AddProperty(_RelationTransformerBase, _NodeTransformerBase):\n\"\"\"Add a property to a node\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(NodeTrans.AddProperty({\"my_new_prop_key\":\"my_new_prop_value_1111\"}))\n        )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{name:'Camina',my_new_prop_key:\"my_new_prop_value_1111\"})`.\n    \"\"\"\ndef __init__(self, properties: Dict):\n\"\"\"_summary_\n        Args:\n            properties (Union[str, List[str]]): A property key or a list of property keys as strings that should be removed\n        \"\"\"\nif isinstance(properties, str):\nproperties = [properties]\nself.properties = properties\ndef transform_node(self, node: Node):\nself._transform(node)\ndef transform_rel(self, rel: Relation):\nself._transform(rel)\ndef _transform(self, obj: Union[Node, Relation]):\nobj.update(self.properties)\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.AddProperty.__init__","title":"<code>__init__(properties)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>Union[str, List[str]]</code> <p>A property key or a list of property keys as strings that should be removed</p> required Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>def __init__(self, properties: Dict):\n\"\"\"_summary_\n    Args:\n        properties (Union[str, List[str]]): A property key or a list of property keys as strings that should be removed\n    \"\"\"\nif isinstance(properties, str):\nproperties = [properties]\nself.properties = properties\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.OverridePropertyName","title":"<code>OverridePropertyName</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code>, <code>_NodeTransformerBase</code></p> <p>Replace a property name/key with a new string of your choice. Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina Drummer\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(NodeTrans.OverridePropertyName(\"name\",\"fullname\"))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{fullname:'Camina Drummer'})</code></p> Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>class OverridePropertyName(_RelationTransformerBase, _NodeTransformerBase):\n\"\"\"Replace a property name/key with a new string of your choice.\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina Drummer\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(NodeTrans.OverridePropertyName(\"name\",\"fullname\"))\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{fullname:'Camina Drummer'})`\n    \"\"\"\ndef __init__(self, source_property_name: str, target_property_name: str):\n\"\"\"\n        Args:\n            source_property_name (str): The property key you want to be replaced.\n            target_property_name (str): The The new name of the property.\n        \"\"\"\nself.source_property_name = source_property_name\nself.target_property_name = target_property_name\ndef _transform(self, obj: Dict):\nif self.source_property_name in obj:\nobj[self.target_property_name] = obj.pop(self.source_property_name)\ndef transform_node(self, node: Node):\nself._transform(node)\ndef transform_rel(self, rel: Relation):\nself._transform(rel)\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.OverridePropertyName.__init__","title":"<code>__init__(source_property_name, target_property_name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source_property_name</code> <code>str</code> <p>The property key you want to be replaced.</p> required <code>target_property_name</code> <code>str</code> <p>The The new name of the property.</p> required Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>def __init__(self, source_property_name: str, target_property_name: str):\n\"\"\"\n    Args:\n        source_property_name (str): The property key you want to be replaced.\n        target_property_name (str): The The new name of the property.\n    \"\"\"\nself.source_property_name = source_property_name\nself.target_property_name = target_property_name\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.RemoveProperty","title":"<code>RemoveProperty</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code>, <code>_NodeTransformerBase</code></p> <p>Remove a property from a node Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina\", \"id\":\"sdf343\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(NodeTrans.RemoveProperty(id))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{name:'Camina'})</code>. the <code>id</code> property will be thrown away.</p> Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>class RemoveProperty(_RelationTransformerBase, _NodeTransformerBase):\n\"\"\"Remove a property from a node\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina\", \"id\":\"sdf343\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(NodeTrans.RemoveProperty(id))\n        )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{name:'Camina'})`. the `id` property will be thrown away.\n    \"\"\"\ndef __init__(self, property_keys: Union[str, List[str]]):\n\"\"\"_summary_\n        Args:\n            properties (Union[str, List[str]]): A property key or a list of property keys as strings that should be removed\n        \"\"\"\nif isinstance(property_keys, str):\nproperty_keys = [property_keys]\nself.property_keys = property_keys\ndef custom_node_match(self, node: Node) -&gt; bool:\n# check if node keys and defined properties have an overlap\nreturn not set(self.property_keys).isdisjoint(set(node.keys()))\ndef transform_node(self, node: Node):\nself._transform(node)\ndef transform_rel(self, rel: Relation):\nself._transform(rel)\ndef _transform(self, obj: Union[Node, Relation]):\nfor prop in self.property_keys:\nobj.pop(prop, None)\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.RemoveProperty.__init__","title":"<code>__init__(property_keys)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>Union[str, List[str]]</code> <p>A property key or a list of property keys as strings that should be removed</p> required Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>def __init__(self, property_keys: Union[str, List[str]]):\n\"\"\"_summary_\n    Args:\n        properties (Union[str, List[str]]): A property key or a list of property keys as strings that should be removed\n    \"\"\"\nif isinstance(property_keys, str):\nproperty_keys = [property_keys]\nself.property_keys = property_keys\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.TypeCastProperty","title":"<code>TypeCastProperty</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code>, <code>_NodeTransformerBase</code></p> <p>change the type of property values. Usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina\", \"captain\":\"true\", \"age\":\"39\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation([\nTransformer.match_nodes(\"person\").do(NodeTrans.TypeCastProperty(\"captain\",bool)),\nTransformer.match_nodes(\"person\").do(NodeTrans.TypeCastProperty(\"age\",int)),\n])\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{name:'Camina',captain:true,age:27})</code></p> Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>class TypeCastProperty(_RelationTransformerBase, _NodeTransformerBase):\n\"\"\"change the type of property values.\n    Usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina\", \"captain\":\"true\", \"age\":\"39\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation([\n        Transformer.match_nodes(\"person\").do(NodeTrans.TypeCastProperty(\"captain\",bool)),\n        Transformer.match_nodes(\"person\").do(NodeTrans.TypeCastProperty(\"age\",int)),\n    ])\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{name:'Camina',captain:true,age:27})`\n    \"\"\"\ndef __init__(self, property_name: str, target_type: Union[str, int, float, bool]):\n\"\"\"\n        Args:\n            property_name (str): The property key that should be changed\n            target_type (Union[str, int, float, bool]): The type that should result\n        \"\"\"\nself.property_name = property_name\nself.target_type = target_type\ndef _transform(self, obj: Dict):\nif self.property_name in obj:\nif self.target_type == bool:\nobj[self.property_name] = True\nif obj[self.property_name] in [\n0,\n\"0\",\nNone,\n\"Null\",\n\"false\",\n\"False\",\n\"f\",\n\"F\",\n\"No\",\n\"no\",\n]:\nobj[self.property_name] = False\nelse:\nobj[self.property_name] = self.target_type(obj[self.property_name])\ndef transform_node(self, node: Node):\nself._transform(node)\ndef transform_rel(self, rel: Relation):\nself._transform(rel)\n</code></pre>"},{"location":"list_generic_transformer/#dict2graph.transformers.generic_transformers.TypeCastProperty.__init__","title":"<code>__init__(property_name, target_type)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>property_name</code> <code>str</code> <p>The property key that should be changed</p> required <code>target_type</code> <code>Union[str, int, float, bool]</code> <p>The type that should result</p> required Source code in <code>dict2graph/transformers/generic_transformers.py</code> <pre><code>def __init__(self, property_name: str, target_type: Union[str, int, float, bool]):\n\"\"\"\n    Args:\n        property_name (str): The property key that should be changed\n        target_type (Union[str, int, float, bool]): The type that should result\n    \"\"\"\nself.property_name = property_name\nself.target_type = target_type\n</code></pre>"},{"location":"list_node_transformer/","title":"Node Transformers","text":"<p>dict2graph comes with a lot of predefined transformators. For a basic concepts of a dict2Graph transformators have a look at How to use Transformators</p>"},{"location":"list_node_transformer/#node-transformators-list","title":"Node Transformators List","text":"<p>This is a list if transformators that can be applied to nodes only</p>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.AddLabel","title":"<code>AddLabel</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Add one or more new labels to nodes</p> <p>Usage:</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina Drummer\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(NodeTrans.AddLabel(\"Character\"))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>Results in a Neo4j node <code>(:person:Character{name:'Camina Drummer'})</code></p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class AddLabel(_NodeTransformerBase):\n\"\"\"Add one or more new labels to nodes\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina Drummer\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(NodeTrans.AddLabel(\"Character\"))\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:person:Character{name:'Camina Drummer'})`\n    \"\"\"\ndef __init__(self, labels: Union[str, List[str]]):\n\"\"\"_summary_\n        Args:\n            labels (Union[str, List[str]]): A string or a list of strings that will be added as new labels to the matched nodes\n        \"\"\"\nif isinstance(labels, str):\nlabels = [labels]\nself.new_labels = labels\ndef transform_node(self, node: Node):\nnode.labels = node.labels + self.new_labels\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.AddLabel.__init__","title":"<code>__init__(labels)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>Union[str, List[str]]</code> <p>A string or a list of strings that will be added as new labels to the matched nodes</p> required Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(self, labels: Union[str, List[str]]):\n\"\"\"_summary_\n    Args:\n        labels (Union[str, List[str]]): A string or a list of strings that will be added as new labels to the matched nodes\n    \"\"\"\nif isinstance(labels, str):\nlabels = [labels]\nself.new_labels = labels\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.CapitalizeLabels","title":"<code>CapitalizeLabels</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Uppercase the first char of node labels.</p> <p>Usage:</p> <p><pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina Drummer\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(NodeTrans.CapitalizeLabels())\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Person{name:'Camina Drummer'})</code></p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class CapitalizeLabels(_NodeTransformerBase):\n\"\"\"Uppercase the first char of node labels.\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina Drummer\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(NodeTrans.CapitalizeLabels())\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Person{name:'Camina Drummer'})`\n    \"\"\"\ndef transform_node(self, node: Node):\nnode.labels = [label.capitalize() for label in node.labels]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.CreateHubbing","title":"<code>CreateHubbing</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class CreateHubbing(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(\nself,\nfollow_nodes_labels: List[str],\nmerge_mode: Literal[\"lead\", \"edge\"],\nhub_labels: List[str] = [\"Hub\"],\n):\nif len(follow_nodes_labels) &lt;= 1:\nraise ValueError(\nf\"At least chains of 3 node are needed for hubbing. Please provide min. 2 `follow_nodes_labels`. Got only {len(follow_nodes_labels)} labels\"\n)\nif merge_mode.upper() not in [\"LEAD\", \"EDGE\"]:\nraise ValueError(\nf\"Only 'lead' and 'edge' mode are supported. got '{merge_mode}'\"\n)\nself.follow_nodes_labels = follow_nodes_labels\nself.merge_mode = merge_mode\nif isinstance(hub_labels, str):\nhub_labels = [hub_labels]\nself.hub_labels = hub_labels\ndef custom_node_match(self, node: Node) -&gt; bool:\n# walk the node tree to check if this subtree needs to be hubbed.\n# if all follow_nodes_labels exists in the right order, according follow_nodes_labels, to we will hub\nreturn len(\nlist(self._walk_follow_nodes(node, self.follow_nodes_labels))\n) &gt;= len(self.follow_nodes_labels)\ndef transform_node(self, node: Node):\nhub = Node(labels=self.hub_labels, source_data={}, parent_node=node)\nstart_node: Node = node\nfill_nodes: List[Node] = []\nend_node: Node = None\nfor follow_node, follow_rel in self._walk_follow_nodes(\nnode, follow_nodes_labels=self.follow_nodes_labels\n):\nend_node = follow_node\nfill_nodes.append(follow_node)\nfollow_rel.start_node = hub\nfill_nodes.remove(end_node)\nhash_sources = []\nif self.merge_mode.upper() == \"EDGE\":\nhash_sources.append(start_node.get_hash())\nhash_sources.append(end_node.get_hash())\nelif self.merge_mode.upper() == \"LEAD\":\nhash_sources.extend([n.get_hash() for n in fill_nodes])\nhub[self.d2g.list_hub_id_property_name] = hashlib.md5(\n\"\".join(hash_sources).encode(\"utf-8\")\n).hexdigest()\nself.d2g.add_node_to_cache(hub)\nself.d2g.add_rel_to_cache(Relation(start_node=node, end_node=hub))\ndef _walk_follow_nodes(\nself, node: Node, follow_nodes_labels: List[str]\n) -&gt; Generator[Tuple[Node, Relation], None, None]:\nif len(follow_nodes_labels) == 0:\nreturn\nfor o_rel in [r for r in node.outgoing_relations if not r.deleted]:\nfor end_node_label in o_rel.end_node.labels:\nif end_node_label in follow_nodes_labels[0]:\nyield o_rel.end_node, o_rel\nfor n, r in self._walk_follow_nodes(\no_rel.end_node,\n[l for l in follow_nodes_labels if l != end_node_label],\n):\nyield n, r\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.CreateNewMergePropertyFromHash","title":"<code>CreateNewMergePropertyFromHash</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Create a new merge-property for the node. The value of this property will be a configurable hash. See init() for configruation details.</p> <p>Usage:</p> <p><pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = [\n{\"person\": {\"fname\": \"Joe \", \"lname\": \"Miller\", \"domiciles\": [\"Ceres\", \"Belt\", \"SOL\"]}},\n{\"person\": {\"fname\": \"Joe \", \"lname\": \"Miller\", \"domiciles\": [\"Earth\"]}},\n]\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(\nNodeTrans.CreateNewMergePropertyFromHash(\nhash_includes_children_data=True\n)\n)\n)\nd2g.parse(dic)\nd2g.merge(NEO4J_DRIVER)\n</code></pre> Results in a Graph with two different <code>Joe Miller</code>s.</p> <p>Initially the disambiguation is only determinable by the <code>Joe Miller</code> child nodes <code>domiciles</code>. With <code>NodeTrans.CreateNewMergePropertyFromHash</code> we can create a hash from the node and its children. This way merging will not result in false positives regarding distinguishing objects. See <code>__init__()</code> for more options to modify the hash.</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class CreateNewMergePropertyFromHash(_NodeTransformerBase):\n\"\"\"Create a new merge-property for the node.\n    The value of this property will be a configurable hash.\n    See __init__() for configruation details.\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = [\n        {\"person\": {\"fname\": \"Joe \", \"lname\": \"Miller\", \"domiciles\": [\"Ceres\", \"Belt\", \"SOL\"]}},\n        {\"person\": {\"fname\": \"Joe \", \"lname\": \"Miller\", \"domiciles\": [\"Earth\"]}},\n    ]\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(\n            NodeTrans.CreateNewMergePropertyFromHash(\n                hash_includes_children_data=True\n            )\n        )\n    )\n    d2g.parse(dic)\n    d2g.merge(NEO4J_DRIVER)\n    ```\n    Results in a Graph with two different `Joe Miller`s.\n    Initially the disambiguation is only determinable by the `Joe Miller` child nodes `domiciles`.\n    With `NodeTrans.CreateNewMergePropertyFromHash` we can create a hash from the node and its children.\n    This way merging will not result in false positives regarding distinguishing objects.\n    See `__init__()` for more options to modify the hash.\n    \"\"\"\ndef __init__(\nself,\nhash_includes_properties: List[str] = None,\nhash_includes_existing_merge_props: bool = False,\nhash_includes_existing_other_props: bool = False,\nhash_includes_children_nodes_merge_properties: bool = False,\nhash_includes_children_data: bool = False,\nhash_includes_parent_merge_properties: bool = False,\nnew_merge_property_name: str = \"_id\",\n):\n\"\"\"_summary_\n        Args:\n            hash_includes_properties (List[str], optional): Define certain properties to go into the hash. Defaults to None.\n            hash_includes_existing_merge_props (bool, optional): Include merge-properties in the hash. Defaults to False.\n            hash_includes_existing_other_props (bool, optional): Include all non merge-properties in the hash. Defaults to False.\n            hash_includes_children_nodes_merge_properties (bool, optional): Include all merge-properties of all direct child nodes. Defaults to False.\n            hash_includes_children_data (bool, optional): Include all data from direct and indirect children. Defaults to False.\n            hash_includes_parent_merge_properties (bool, optional): Include merge properties of parent nodes. Defaults to False.\n            new_merge_property_name (str, optional): The key for the newly generated property. Defaults to \"_id\".\n        \"\"\"\nself.hash_includes_existing_merge_props = hash_includes_existing_merge_props\nself.hash_includes_existing_other_props = hash_includes_existing_other_props\nself.hash_includes_properties = hash_includes_properties\nself.hash_includes_children_nodes_merge_properties = (\nhash_includes_children_nodes_merge_properties\n)\nself.hash_includes_children_data = hash_includes_children_data\nself.hash_includes_children_data = hash_includes_children_data\nself.hash_includes_parent_merge_properties = (\nhash_includes_parent_merge_properties\n)\nself.new_merge_property_name = new_merge_property_name\ndef transform_node(self, node: Node):\nif self.hash_includes_properties:\nnode.merge_property_keys = list(\nset(node.merge_property_keys + self.hash_includes_properties)\n)\nnode[self.new_merge_property_name] = node.get_hash(\ninclude_properties=self.hash_includes_properties,\ninclude_merge_properties=self.hash_includes_existing_merge_props,\ninclude_other_properties=self.hash_includes_existing_other_props,\ninclude_parent_properties=self.hash_includes_parent_merge_properties,\ninclude_children_properties=self.hash_includes_children_nodes_merge_properties,\ninclude_children_data=self.hash_includes_children_data,\n)\nnode.merge_property_keys = [self.new_merge_property_name]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.CreateNewMergePropertyFromHash.__init__","title":"<code>__init__(hash_includes_properties=None, hash_includes_existing_merge_props=False, hash_includes_existing_other_props=False, hash_includes_children_nodes_merge_properties=False, hash_includes_children_data=False, hash_includes_parent_merge_properties=False, new_merge_property_name='_id')</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>hash_includes_properties</code> <code>List[str]</code> <p>Define certain properties to go into the hash. Defaults to None.</p> <code>None</code> <code>hash_includes_existing_merge_props</code> <code>bool</code> <p>Include merge-properties in the hash. Defaults to False.</p> <code>False</code> <code>hash_includes_existing_other_props</code> <code>bool</code> <p>Include all non merge-properties in the hash. Defaults to False.</p> <code>False</code> <code>hash_includes_children_nodes_merge_properties</code> <code>bool</code> <p>Include all merge-properties of all direct child nodes. Defaults to False.</p> <code>False</code> <code>hash_includes_children_data</code> <code>bool</code> <p>Include all data from direct and indirect children. Defaults to False.</p> <code>False</code> <code>hash_includes_parent_merge_properties</code> <code>bool</code> <p>Include merge properties of parent nodes. Defaults to False.</p> <code>False</code> <code>new_merge_property_name</code> <code>str</code> <p>The key for the newly generated property. Defaults to \"_id\".</p> <code>'_id'</code> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(\nself,\nhash_includes_properties: List[str] = None,\nhash_includes_existing_merge_props: bool = False,\nhash_includes_existing_other_props: bool = False,\nhash_includes_children_nodes_merge_properties: bool = False,\nhash_includes_children_data: bool = False,\nhash_includes_parent_merge_properties: bool = False,\nnew_merge_property_name: str = \"_id\",\n):\n\"\"\"_summary_\n    Args:\n        hash_includes_properties (List[str], optional): Define certain properties to go into the hash. Defaults to None.\n        hash_includes_existing_merge_props (bool, optional): Include merge-properties in the hash. Defaults to False.\n        hash_includes_existing_other_props (bool, optional): Include all non merge-properties in the hash. Defaults to False.\n        hash_includes_children_nodes_merge_properties (bool, optional): Include all merge-properties of all direct child nodes. Defaults to False.\n        hash_includes_children_data (bool, optional): Include all data from direct and indirect children. Defaults to False.\n        hash_includes_parent_merge_properties (bool, optional): Include merge properties of parent nodes. Defaults to False.\n        new_merge_property_name (str, optional): The key for the newly generated property. Defaults to \"_id\".\n    \"\"\"\nself.hash_includes_existing_merge_props = hash_includes_existing_merge_props\nself.hash_includes_existing_other_props = hash_includes_existing_other_props\nself.hash_includes_properties = hash_includes_properties\nself.hash_includes_children_nodes_merge_properties = (\nhash_includes_children_nodes_merge_properties\n)\nself.hash_includes_children_data = hash_includes_children_data\nself.hash_includes_children_data = hash_includes_children_data\nself.hash_includes_parent_merge_properties = (\nhash_includes_parent_merge_properties\n)\nself.new_merge_property_name = new_merge_property_name\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.MergeChildNodes","title":"<code>MergeChildNodes</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class MergeChildNodes(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(\nself,\nchild_labels: Union[str, AnyLabel] = AnyLabel,\nchild_relation_type: Union[str, AnyRelation] = AnyRelation,\noverwrite_existing_props: bool = True,\nprefix_merged_props_with_primary_label_of_child: bool = False,\nprefix_merged_props_with_hash_of_child: bool = False,\ninclude_relation_props: bool = True,\n):\nself.child_labels = child_labels\nself.child_relation_type = child_relation_type\nself.overwrite_existing_props = overwrite_existing_props\nself.prefix_merged_props_with_primary_label = (\nprefix_merged_props_with_primary_label_of_child\n)\nself.prefix_merged_props_with_hash_of_child = (\nprefix_merged_props_with_hash_of_child\n)\nself.include_relation_props = include_relation_props\ndef transform_node(self, node: Node):\nfor outgoing_rel in node.outgoing_relations:\nchild_node = outgoing_rel.end_node\nif not (\nself.child_labels == AnyLabel\nor set(self.child_labels).issubset(set(child_node.labels))\n):\ncontinue\nif not (\nself.child_relation_type == AnyRelation\nor outgoing_rel.relation_type == self.child_relation_type\n):\ncontinue\nif self.include_relation_props:\nself._merge_props(target_node=node, obj=outgoing_rel)\nself._merge_props(target_node=node, obj=child_node)\nfor outgoing_child_rel in child_node.outgoing_relations:\noutgoing_child_rel.start_node = node\nfor incoming_child_rel in child_node.incoming_relations:\nif incoming_child_rel.start_node != node:\nincoming_child_rel.start_node = node\nelse:\nincoming_child_rel.deleted = True\nchild_node.deleted = True\ndef _merge_props(\nself,\ntarget_node: Node,\nobj: Union[Node, Relation],\n):\nfor key, val in obj.items():\nresult_key = key\nif self.prefix_merged_props_with_primary_label:\nprefix = (\nobj.primary_label if isinstance(obj, Node) else obj.relation_type\n)\nresult_key = f\"{prefix}_{result_key}\"\nif self.prefix_merged_props_with_hash_of_child and isinstance(obj, Node):\nresult_key = f\"{obj.get_hash()}_{result_key}\"\nif key in target_node and not self.overwrite_existing_props:\nmax_index = max(\n[\nk.split(\"_\")[-1]\nfor k in list(target_node.keys())\nif k.startswith(key) and k.split(\"_\")[-1].isnumeric()\n],\ndefault=\"-1\",\n)\nresult_key = f\"{result_key}_{int(max_index)+1}\"\ntarget_node[result_key] = val\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.OutsourcePropertiesToNewNode","title":"<code>OutsourcePropertiesToNewNode</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Move one or multiple properties to a new node.</p> <p>Usage:</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"fname\": \"Marco \", \"lname\": \"Inaros\", \"child\": \"Filip Inaros\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(\nNodeTrans.OutsourcePropertiesToNewNode(\nproperty_keys=[\"child\"],\nnew_node_labels=[\"person\"],\nrelation_type=\"person_has_child\",\n)\n)\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>instead of only one person-\"Marco Inaros\"-node, with a property \"child:'Filip Inaros'\", we have a second person-\"Filip Inaros\"-node. They are connected with a relation <code>person_has_child</code>.</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class OutsourcePropertiesToNewNode(_NodeTransformerBase):\n\"\"\"Move one or multiple properties to a new node.\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"fname\": \"Marco \", \"lname\": \"Inaros\", \"child\": \"Filip Inaros\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(\n            NodeTrans.OutsourcePropertiesToNewNode(\n                property_keys=[\"child\"],\n                new_node_labels=[\"person\"],\n                relation_type=\"person_has_child\",\n            )\n        )\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    instead of only one person-\"Marco Inaros\"-node, with a property \"child:'Filip Inaros'\", we have a second person-\"Filip Inaros\"-node.\n    They are connected with a relation `person_has_child`.\n    \"\"\"\ndef __init__(\nself,\nproperty_keys: List[str],\nnew_node_labels: List[str],\nrelation_type: str = None,\nskip_if_prop_val_empty: bool = True,\n):\nself.property_keys = property_keys\nself.new_node_labels = new_node_labels\nself.relation_type = relation_type\nself.skip_if_prop_val_empty = skip_if_prop_val_empty\ndef transform_node(self, node: Node):\noutsourced_props_node: Node = Node(\nlabels=self.new_node_labels, source_data={}, parent_node=node\n)\nfor key in self.property_keys:\nif key in node:\noutsourced_props_node[key] = node.pop(key)\nif not outsourced_props_node and self.skip_if_prop_val_empty:\nreturn\nself.d2g.add_node_to_cache(outsourced_props_node)\nself.d2g.add_rel_to_cache(\nRelation(node, outsourced_props_node, relation_type=self.relation_type)\n)\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.OutsourcePropertiesToRelationship","title":"<code>OutsourcePropertiesToRelationship</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Move one or multiple properties to an existing relation.</p> <p>Usage:</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\n\"person\": {\n\"fname\": \"Marco \",\n\"lname\": \"Inaros\",\n\"child_rel\": \"biological\",\n\"child\": {\"person\": {\"fname\": \"Filip\", \"lname\": \"Inaros\"}},\n}\n}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(\nNodeTrans.OutsourcePropertiesToRelationship(\nproperty_keys=[\"child_rel\"],\nrelation_type=\"child\",\n)\n)\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>Shifts the fathers prop <code>\"child_rel\": \"biological\"</code> on the relation between child and father.</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class OutsourcePropertiesToRelationship(_NodeTransformerBase):\n\"\"\"Move one or multiple properties to an existing relation.\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\n        \"person\": {\n            \"fname\": \"Marco \",\n            \"lname\": \"Inaros\",\n            \"child_rel\": \"biological\",\n            \"child\": {\"person\": {\"fname\": \"Filip\", \"lname\": \"Inaros\"}},\n        }\n    }\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(\n            NodeTrans.OutsourcePropertiesToRelationship(\n                property_keys=[\"child_rel\"],\n                relation_type=\"child\",\n            )\n        )\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Shifts the fathers prop `\"child_rel\": \"biological\"` on the relation between child and father.\n    \"\"\"\ndef __init__(\nself,\nproperty_keys: List[str],\nrelation_type: str = None,\nskip_if_prop_val_empty: bool = False,\nkeep_prop_if_relation_does_not_exist: bool = True,\n):\n\"\"\"_summary_\n        Args:\n            property_keys (List[str]): The properties, defined by their keys, that should be moved to the relationship.\n            relation_type (str, optional): The relation, the properties should me moved to. Defaults to None.\n            skip_if_prop_val_empty (bool, optional): If the property has no value, dont move it to the relation. Defaults to False.\n            keep_prop_if_relation_does_not_exist (bool, optional): Should the property be removed from the node, even if there is no relation it can move to. Defaults to True.\n        \"\"\"\nself.property_keys = property_keys\nself.relation_type = relation_type\nself.skip_if_prop_val_empty = skip_if_prop_val_empty\nself.keep_prop_if_relation_does_not_exist = keep_prop_if_relation_does_not_exist\ndef transform_node(self, node: Node):\nfor rel in node.relations:\nif rel.relation_type == self.relation_type:\nfor prop in self.property_keys:\nif prop in node and (\nnode[prop] not in [\"\", None] or not self.skip_if_prop_val_empty\n):\nrel[prop] = node.pop(prop)\nif not self.keep_prop_if_relation_does_not_exist:\n[node.pop(prop, None) for prop in self.property_keys]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.OutsourcePropertiesToRelationship.__init__","title":"<code>__init__(property_keys, relation_type=None, skip_if_prop_val_empty=False, keep_prop_if_relation_does_not_exist=True)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>property_keys</code> <code>List[str]</code> <p>The properties, defined by their keys, that should be moved to the relationship.</p> required <code>relation_type</code> <code>str</code> <p>The relation, the properties should me moved to. Defaults to None.</p> <code>None</code> <code>skip_if_prop_val_empty</code> <code>bool</code> <p>If the property has no value, dont move it to the relation. Defaults to False.</p> <code>False</code> <code>keep_prop_if_relation_does_not_exist</code> <code>bool</code> <p>Should the property be removed from the node, even if there is no relation it can move to. Defaults to True.</p> <code>True</code> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(\nself,\nproperty_keys: List[str],\nrelation_type: str = None,\nskip_if_prop_val_empty: bool = False,\nkeep_prop_if_relation_does_not_exist: bool = True,\n):\n\"\"\"_summary_\n    Args:\n        property_keys (List[str]): The properties, defined by their keys, that should be moved to the relationship.\n        relation_type (str, optional): The relation, the properties should me moved to. Defaults to None.\n        skip_if_prop_val_empty (bool, optional): If the property has no value, dont move it to the relation. Defaults to False.\n        keep_prop_if_relation_does_not_exist (bool, optional): Should the property be removed from the node, even if there is no relation it can move to. Defaults to True.\n    \"\"\"\nself.property_keys = property_keys\nself.relation_type = relation_type\nself.skip_if_prop_val_empty = skip_if_prop_val_empty\nself.keep_prop_if_relation_does_not_exist = keep_prop_if_relation_does_not_exist\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.OverrideLabel","title":"<code>OverrideLabel</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Replace a node label with a new string Usage:</p> <p><pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": {\"name\": \"Camina Drummer\"}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(NodeTrans.OverrideLabel(\"Character\"))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> Results in a Neo4j node <code>(:Character{name:'Camina Drummer'})</code></p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class OverrideLabel(_NodeTransformerBase):\n\"\"\"Replace a node label with a new string\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": {\"name\": \"Camina Drummer\"}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(NodeTrans.OverrideLabel(\"Character\"))\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in a Neo4j node `(:Character{name:'Camina Drummer'})`\n    \"\"\"\ndef __init__(self, value: str, target_label: str = None):\n\"\"\"_summary_\n        Args:\n            value (str): The new labels string.\n            target_label (str, optional): The label you want to be replaced.\n                If none, the labels defined in the `node_match()` function will be replaced.\n                Defaults to None.\n        Raises:\n            ValueError: _description_\n        \"\"\"\nif not value:\nraise ValueError(f\"Value must be a string. Got '{value}'\")\nself.value = value\nself.target_label = target_label\ndef transform_node(self, node: Node):\nif self.target_label:\nreplace_labels = [self.target_label]\nelse:\nreplace_labels = self.matcher.label_match\nfor origin_label in replace_labels:\nnode.labels = list(\nmap(lambda x: x.replace(origin_label, self.value), node.labels)\n)\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.OverrideLabel.__init__","title":"<code>__init__(value, target_label=None)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The new labels string.</p> required <code>target_label</code> <code>str</code> <p>The label you want to be replaced. If none, the labels defined in the <code>node_match()</code> function will be replaced. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(self, value: str, target_label: str = None):\n\"\"\"_summary_\n    Args:\n        value (str): The new labels string.\n        target_label (str, optional): The label you want to be replaced.\n            If none, the labels defined in the `node_match()` function will be replaced.\n            Defaults to None.\n    Raises:\n        ValueError: _description_\n    \"\"\"\nif not value:\nraise ValueError(f\"Value must be a string. Got '{value}'\")\nself.value = value\nself.target_label = target_label\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.PopListHubNodes","title":"<code>PopListHubNodes</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>When dict2grapg parses dict lists it create a hub node to attach all list items. In most cases this is unnecessary and will make your graph model larger as it has to be. <code>PopListHubNodes</code> will just remove these list hubs.</p> <p>Usage:</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata = {\n\"bookshelf\": {\n\"book\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n\"condition\": \"good\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n\"condition\": \"bad\",\n},\n]\n}\n}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes().do(NodeTrans.PopListHubNodes())\n)\nd2g.parse(data)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>This will result in a <code>(:bookshelf)</code>node directly connected to 2 <code>(:book)</code> nodes instead of a <code>:ListHub:book</code> node in between.</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class PopListHubNodes(_NodeTransformerBase):\n\"\"\"When dict2grapg parses dict lists it create a hub node to attach all list items.\n    In most cases this is unnecessary and will make your graph model larger as it has to be.\n    `PopListHubNodes` will just remove these list hubs.\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    data = {\n        \"bookshelf\": {\n            \"book\": [\n                {\n                    \"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n                    \"condition\": \"good\",\n                },\n                {\n                    \"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n                    \"condition\": \"bad\",\n                },\n            ]\n        }\n    }\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes().do(NodeTrans.PopListHubNodes())\n    )\n    d2g.parse(data)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    This will result in a `(:bookshelf)`node directly connected to 2 `(:book)` nodes instead of a `:ListHub:book` node in between.\n    \"\"\"\ndef custom_node_match(self, node: Node) -&gt; bool:\nreturn node.is_list_list_hub\ndef transform_node(self, node: Node):\nnew_list_item_nodes_parent = node.parent_node\nfor list_item_rel in node.outgoing_relations:\nif new_list_item_nodes_parent is not None:\nlist_item_rel.start_node = new_list_item_nodes_parent\nelse:\n# we are at the root node level. the list will now without any parent.\nlist_item_rel.deleted\nfor parent_rels in node.incoming_relations:\nparent_rels.deleted = True\nnode.deleted = True\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.PopNode","title":"<code>PopNode</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class PopNode(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef transform_node(self, node: Node):\nfor i_rel in node.incoming_relations:\nfor o_rel in node.outgoing_relations:\ni_rel.end_node = o_rel.end_node\nnode.deleted\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveEmptyListRootNodes","title":"<code>RemoveEmptyListRootNodes</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Remove any list root/hub nodes with no children.</p> <p>Usage:</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\n\"person\": {\"fname\": \"Marco \", \"lname\": \"Inaros\", \"children\": [\"Filip Inaros\"]}\n}\ndic2 = {\"person\": {\"fname\": \"Joe \", \"lname\": \"Miller\", \"children\": []}}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"children\").do(NodeTrans.RemoveEmptyListRootNodes())\n)\nd2g.parse(dic)\nd2g.parse(dic2)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>Results in two person nodes. The <code>Joe Miller</code>-node will not have any <code>children</code> list nodes related. Without the <code>RemoveEmptyListRootNodes</code> the <code>Joe Miller</code>-node would have attached an empty <code>ListHub:Children</code>-node</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveEmptyListRootNodes(_NodeTransformerBase):\n\"\"\"Remove any list root/hub nodes with no children.\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\n        \"person\": {\"fname\": \"Marco \", \"lname\": \"Inaros\", \"children\": [\"Filip Inaros\"]}\n    }\n    dic2 = {\"person\": {\"fname\": \"Joe \", \"lname\": \"Miller\", \"children\": []}}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"children\").do(NodeTrans.RemoveEmptyListRootNodes())\n    )\n    d2g.parse(dic)\n    d2g.parse(dic2)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in two person nodes. The `Joe Miller`-node will not have any `children` list nodes related.\n    Without the `RemoveEmptyListRootNodes` the `Joe Miller`-node would have attached an empty `ListHub:Children`-node\n    \"\"\"\ndef custom_node_match(self, node: Node) -&gt; bool:\nreturn node.is_list_list_hub and len(node.outgoing_relations) == 0\ndef transform_node(self, node: Node):\nfor rel in node.relations:\nrel.deleted = True\nnode.deleted = True\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveLabel","title":"<code>RemoveLabel</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Remove a certain label from nodes</p> <p>Usage:</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\"person\": [{\"name\": \"Camina Drummer\"},{\"name\":\"James Holden\"}]}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"person\").do(NodeTrans.RemoveLabel(\"ListItem\"))\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>Results in removing the <code>:ListItem</code> label from <code>:Person</code> nodes</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveLabel(_NodeTransformerBase):\n\"\"\"Remove a certain label from nodes\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\"person\": [{\"name\": \"Camina Drummer\"},{\"name\":\"James Holden\"}]}\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"person\").do(NodeTrans.RemoveLabel(\"ListItem\"))\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in removing the `:ListItem` label from `:Person` nodes\n    \"\"\"\ndef __init__(self, target_label: str = None):\n\"\"\"_summary_\n        Args:\n            target_label (str, optional): Optional set this if you dont want the labels from `match_nodes()` to be replaced. Defaults to None.\n        Raises:\n            ValueError: _description_\n        \"\"\"\nself.target_label = target_label\ndef transform_node(self, node: Node):\nif self.target_label == AnyLabel:\nnode.labels = []\nelif self.target_label is None:\nnode.labels = [l for l in node.labels if l not in self.matcher.label_match]\nelif isinstance(self.target_label, str):\nnode.labels = [l for l in node.labels if l != self.target_label]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveLabel.__init__","title":"<code>__init__(target_label=None)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>target_label</code> <code>str</code> <p>Optional set this if you dont want the labels from <code>match_nodes()</code> to be replaced. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(self, target_label: str = None):\n\"\"\"_summary_\n    Args:\n        target_label (str, optional): Optional set this if you dont want the labels from `match_nodes()` to be replaced. Defaults to None.\n    Raises:\n        ValueError: _description_\n    \"\"\"\nself.target_label = target_label\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveListItemLabels","title":"<code>RemoveListItemLabels</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Remove <code>ListItem</code> labels that are automatic attached to every list item by dict2graph.     Usage:</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\n\"person\": {\"fname\": \"Marco \", \"lname\": \"Inaros\", \"children\": [\"Filip Inaros\"]}\n}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes().do(NodeTrans.RemoveListItemLabels())\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>The \"Filip Inaros\"-<code>children</code>-node will not have an extra label <code>ListItem</code>.</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveListItemLabels(_NodeTransformerBase):\n\"\"\"Remove `ListItem` labels that are automatic attached to every list item by dict2graph.\n        **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\n        \"person\": {\"fname\": \"Marco \", \"lname\": \"Inaros\", \"children\": [\"Filip Inaros\"]}\n    }\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes().do(NodeTrans.RemoveListItemLabels())\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    The \"Filip Inaros\"-`children`-node will not have an extra label `ListItem`.\n    \"\"\"\ndef custom_node_match(self, node: Node) -&gt; bool:\nreturn node.is_list_list_item\ndef transform_node(self, node: Node):\nnode.labels = [\nl for l in node.labels if l not in self.d2g.list_item_additional_labels\n]\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveNode","title":"<code>RemoveNode</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Removes matched nodes.</p> <p>Usage:</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\n\"person\": {\n\"fname\": \"Marco \",\n\"lname\": \"Inaros\",\n\"child\": {\"fname\": \"Filip\", \"lname\": \"Inaros\"},\n}\n}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"child\").do(\nNodeTrans.RemoveNode()\n)\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>Shifts the fathers prop <code>\"child_rel\": \"biological\"</code> on the relation between child and father.</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveNode(_NodeTransformerBase):\n\"\"\"Removes matched nodes.\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\n        \"person\": {\n            \"fname\": \"Marco \",\n            \"lname\": \"Inaros\",\n            \"child\": {\"fname\": \"Filip\", \"lname\": \"Inaros\"},\n        }\n    }\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"child\").do(\n            NodeTrans.RemoveNode()\n        )\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Shifts the fathers prop `\"child_rel\": \"biological\"` on the relation between child and father.\n    \"\"\"\ndef __init__(self, remove_children: bool = False):\n\"\"\"_summary_\n        Args:\n            remove_children (bool, optional): Remove all nodes and relations down the tree as well. Defaults to False.\n        \"\"\"\nself.remove_children = remove_children\ndef transform_node(self, node: Node):\nnode.deleted = True\nfor o_rel in node.outgoing_relations:\no_rel.deleted = True\nif self.remove_children:\nself.transform_node(o_rel.end_node)\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveNode.__init__","title":"<code>__init__(remove_children=False)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>remove_children</code> <code>bool</code> <p>Remove all nodes and relations down the tree as well. Defaults to False.</p> <code>False</code> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(self, remove_children: bool = False):\n\"\"\"_summary_\n    Args:\n        remove_children (bool, optional): Remove all nodes and relations down the tree as well. Defaults to False.\n    \"\"\"\nself.remove_children = remove_children\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveNodesWithNoProps","title":"<code>RemoveNodesWithNoProps</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Removes nodes if they have no properties. Usage:</p> <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndic = {\n\"person\": {\n\"name\": \"Roberta W. Draper\",\n\"child\": {},\n}\n}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes(\"child\").do(NodeTrans.RemoveNodesWithNoProps())\n)\nd2g.parse(dic)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>Results in removing the empty <code>child</code>-node</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveNodesWithNoProps(_NodeTransformerBase):\n\"\"\"Removes nodes if they have no properties.\n    **Usage:**\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    dic = {\n        \"person\": {\n            \"name\": \"Roberta W. Draper\",\n            \"child\": {},\n        }\n    }\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes(\"child\").do(NodeTrans.RemoveNodesWithNoProps())\n    )\n    d2g.parse(dic)\n    d2g.create(NEO4J_DRIVER)\n    ```\n    Results in removing the empty `child`-node\n    \"\"\"\ndef __init__(self, only_if_no_child_nodes: bool = True):\nself.only_if_no_child_nodes = only_if_no_child_nodes\ndef transform_node(self, node: Node):\nif len(node.keys()) == 0 and (\nnot self.only_if_no_child_nodes or len(node.outgoing_relations) == 0\n):\nnode.deleted = True\nfor o_rel in node.relations:\no_rel.deleted = True\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.RemoveNodesWithOnlyEmptyProps","title":"<code>RemoveNodesWithOnlyEmptyProps</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class RemoveNodesWithOnlyEmptyProps(_NodeTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(self, only_if_no_child_nodes: bool = True):\nself.only_if_no_child_nodes = only_if_no_child_nodes\ndef transform_node(\nself,\nnode: Node,\n):\nif set(node.values()) in [set([None]), set([\"\"]), set([None, \"\"])]:\nif not self.only_if_no_child_nodes or len(node.outgoing_relations) == 0:\nnode.deleted = True\nfor o_rel in node.outgoing_relations:\no_rel.deleted = True\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.SetMergeProperties","title":"<code>SetMergeProperties</code>","text":"<p>         Bases: <code>_NodeTransformerBase</code></p> <p>Set the primary properties that will be taken into account when comparing nodes while merging them together. <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nfrom neo4j import GraphDatabase\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata = {\n\"books\": [\n{\n\"title\": \"Science Behind The Cyberpunks-Genre Awesomeness\",\n},\n{\n\"title\": \"Science Behind The Cyberpunks-Genre Awesomeness\",\n}\n]\n}\nd2g = Dict2graph()\nd2g.add_node_transformation(\nTransformer.match_nodes([\"books\", \"ListItem\"]).do(\nNodeTrans.SetMergeProperties(props=[\"title\"])\n)\n)\nd2g.parse(data)\nd2g.merge(NEO4J_DRIVER)\n</code></pre></p> <p>Will result in one Node <code>(:book)</code> because we only compare by the property <code>title</code> when mergin nodes together.</p> Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>class SetMergeProperties(_NodeTransformerBase):\n\"\"\"Set the primary properties that will be taken into account when comparing nodes while merging them together.\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    from neo4j import GraphDatabase\n    NEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\n    data = {\n        \"books\": [\n            {\n                \"title\": \"Science Behind The Cyberpunks-Genre Awesomeness\",\n            },\n            {\n                \"title\": \"Science Behind The Cyberpunks-Genre Awesomeness\",\n            }\n        ]\n    }\n    d2g = Dict2graph()\n    d2g.add_node_transformation(\n        Transformer.match_nodes([\"books\", \"ListItem\"]).do(\n            NodeTrans.SetMergeProperties(props=[\"title\"])\n        )\n    )\n    d2g.parse(data)\n    d2g.merge(NEO4J_DRIVER)\n    ```\n    Will result in one Node `(:book)` because we only compare by the property `title` when mergin nodes together.\n    \"\"\"\ndef __init__(self, props: List[str]):\n\"\"\"\n        Args:\n            props (List[str]): A list of property keys to take into account for merging.\n        \"\"\"\nself.props = props\ndef transform_node(self, node: Node):\nnode.merge_property_keys = self.props\n</code></pre>"},{"location":"list_node_transformer/#dict2graph.transformers.node_transformers.SetMergeProperties.__init__","title":"<code>__init__(props)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>props</code> <code>List[str]</code> <p>A list of property keys to take into account for merging.</p> required Source code in <code>dict2graph/transformers/node_transformers.py</code> <pre><code>def __init__(self, props: List[str]):\n\"\"\"\n    Args:\n        props (List[str]): A list of property keys to take into account for merging.\n    \"\"\"\nself.props = props\n</code></pre>"},{"location":"list_rel_transformer/","title":"Relationship Transformers","text":"<p>dict2graph comes with a lot of predefined transformators. For a basic concepts of a dict2Graph transformators have a look at How to use Transformators</p>"},{"location":"list_rel_transformer/#relationship-transformators-list","title":"Relationship Transformators List","text":"<p>This is a list if transformators that can be applied to relationships only </p>"},{"location":"list_rel_transformer/#dict2graph.transformers.rel_transformers.FlipNodes","title":"<code>FlipNodes</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/rel_transformers.py</code> <pre><code>class FlipNodes(_RelationTransformerBase):\n\"\"\"_summary_\"\"\"\ndef transform_rel(self, rel: Relation):\nstart_node = rel.start_node\nend_node = rel.end_node\nfor inc_rel in start_node.incoming_relations:\ninc_rel.end_node = end_node\nfor out_rel in end_node.outgoing_relations:\nout_rel.start_node = start_node\nrel.start_node = rel.end_node\nrel.end_node = start_node\n</code></pre>"},{"location":"list_rel_transformer/#dict2graph.transformers.rel_transformers.OverrideReliationType","title":"<code>OverrideReliationType</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/rel_transformers.py</code> <pre><code>class OverrideReliationType(_RelationTransformerBase):\n\"\"\"_summary_\"\"\"\ndef __init__(self, value: str = None):\nif not value:\nraise ValueError(f\"Value must be a string. Got '{value}'\")\nself.value = value\ndef transform_rel(self, rel: Relation):\nrel.relation_type = self.value\n</code></pre>"},{"location":"list_rel_transformer/#dict2graph.transformers.rel_transformers.UppercaseRelationType","title":"<code>UppercaseRelationType</code>","text":"<p>         Bases: <code>_RelationTransformerBase</code></p> <p>summary</p> Source code in <code>dict2graph/transformers/rel_transformers.py</code> <pre><code>class UppercaseRelationType(_RelationTransformerBase):\n\"\"\"_summary_\"\"\"\ndef transform_rel(self, rel: Relation):\nrel.relation_type = rel.relation_type.upper()\n</code></pre>"},{"location":"use_transformers/","title":"Transforming","text":""},{"location":"use_transformers/#what-is-transforming-in-dict2graph","title":"What is transforming in dict2graph","text":"<p>Internally dict2graph is caching all parsed content before passing it down to GraphIO, which loads it into Neo4j. This enables us to influence the model in the dict2graph cache before anything goes to Neo4j. In many usecases this can be more perfomant or just more convenient compared to reshaping the model after its loaded into Neo4j.</p> <p>This \"pre\"-transforming will not cover all use-cases nore will it be more perfomant in all cases. You need to find the right balance.</p>"},{"location":"use_transformers/#how-to-use","title":"How to use","text":"<p>The workflow is:</p> <ul> <li>Create a match/filter for the nodes and relationships you want to manipulate </li> <li>Create a transformer to these nodes and relationships</li> <li>Add the transformer to your <code>Dict2graph</code> instance</li> <li>Parse and load your dict/data</li> </ul>"},{"location":"use_transformers/#matching","title":"Matching","text":"<p>The first step to transform your model is to find the parts you want to manipulate. In dict2graph this is accomplished by matching or filtering nodes and relationships</p> <p><code>TransformMatcher</code>s  are targeting the resulting graph-node labels and relationship-types. To design your <code>TransformMatcher</code> it is recommended to start with a plain run of dict2graph with your data. You then can inspect the resulting nodes and relationships and build matchers to transform these.</p> <p>Hint</p> <p>At the moment matching is very basic. It only cover <code>labels</code> for nodes and <code>types</code> for relationships. Probably there will be more advanced matcher and filters in future versions.</p> <p>Lets imagen we have a dict like the following</p> <pre><code>data = {\n\"bookshelf\": {\n\"Genre\": \"Explaining the world\",\n\"books\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n},\n]\n}\n}\n</code></pre> <p>As a first step lets load it into a neo4j database:</p> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2Graph\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\ndata = {\n\"bookshelf\": {\n\"Genre\": \"Explaining the world\",\n\"books\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n},\n]\n}\n}\nd2g = Dict2graph()\nd2g.parse(data)\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>This result in the following graph</p> <p></p>"},{"location":"use_transformers/#node-matching","title":"Node Matching","text":"<p>If we want to transform certain nodes and relationships (which we will do in a couple of line. i promise), we first need to find them. In dict2graph this is done with so called \"matchers\".</p> <p>The most simple matcher you can build is a \"match everything\" case. Matching everything is also the default case. Just keep the matcher empty.</p> <pre><code>from dict2graph import Transformer, AnyNode\nall_matcher = Transformer.match_nodes()\n# this is equal to \nall_matcher = Transformer.match_nodes(AnyNode)\n</code></pre> <p>If we wanted to change <code>(:books)</code> nodes only we would build a matcher like this:</p> <pre><code>from dict2graph import Transformer\nbooks_matcher = Transformer.match_nodes(\"books\")\n</code></pre> <p>Or we can even match multiple nodes by providing multiples labels.</p> <p><pre><code>from dict2graph import Transformer\nbook_and_shelf_matcher = Transformer.match_nodes(has_one_label_of=[\"books\",\"bookshelf\"])\n</code></pre> This would match <code>(:books)</code> and <code>(:bookshelf)</code> nodes.</p> <p>Filtering out certain labels is also possible <pre><code>from dict2graph import Transformer\nno_bookshelf_matcher = Transformer.match_nodes(has_none_label_of=[\"bookshelf\"])\n</code></pre> This again, would match only the <code>(:books)</code>-nodes.</p>"},{"location":"use_transformers/#relationship-matching","title":"Relationship matching","text":"<p>Relationship matching works similar to node matching but it is maybe even simpler. </p> <p>As a starter lets see how we match all relationships:</p> <pre><code>from dict2graph import Transformer\nall_rels_matcher = Transformer.match_rels()\n</code></pre> <p>which is (again) equal to </p> <pre><code>from dict2graph import Transformer, AnyRelation\nall_rels_matcher = Transformer.match_rels(AnyRelation)\n</code></pre> <p>Now lets match our <code>bookshelf_HAS_books</code> relations.</p> <pre><code>from dict2graph import Transformer\nshelf2book_matcher = Transformer.match_rels(\"bookshelf_HAS_books\")\n</code></pre> <p>Or how about matching both of our relations?</p> <pre><code>from dict2graph import Transformer\nboth_matcher = Transformer.match_rels(\n[\"bookshelf_HAS_books\", \"bookshelf_LIST_HAS_books\"]\n)\n</code></pre> <p>Of course filtering is possible as well. lets filter <code>bookshelf_HAS_books</code> away</p> <pre><code>from dict2graph import Transformer\nfilter_matcher = Transformer.match_rels(\nrelation_type_is_not_in=[\"bookshelf_HAS_books\"]\n)\n</code></pre>"},{"location":"use_transformers/#transforming","title":"Transforming","text":"<p>Great. Now as we know the concept of \"matchers\" and how to collect our nodes and relationships, lets manipulate them. For that we need to create so called <code>Transformer</code>s</p> <p>Lets try to add a new property \"<code>material: 'wood'</code>\" to our bookshelf.</p> <p>We will pick the dict2graph built in node transformer AddProperty</p> <p>For your convenience you can import the wrapper class <code>dict2graph.NodeTrans</code> which includes all Transformers that are applicable to nodes. Same with <code>dict2graph.RelTrans</code> for relationship transformators.</p> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2graph,Transformer, NodeTrans\ndata = {\n\"bookshelf\": {\n\"Genre\": \"Explaining the world\",\n\"books\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n},\n]\n}\n}\n# we just learned how to \"match\". lets apply it:\nbookshelf_matcher = Transformer.match_nodes(\"bookshelf\")\nadd_prop_transformator = NodeTrans.AddProperty({\"material\":\"wood\"})\n# the next thing we should do is to attach the transformator to our dict2graph instance\nmatch_and_transform = bookshelf_matcher.do(add_prop_transformator)\n# to be able to enjoy our work lets push the data to neo4j\n# From here this works the same way as we allready learned in the basic tutorial\nd2g = Dict2graph()\nd2g.add_transformation(match_and_transform)\n# parse our dict...\nd2g.parse(data)\n# ...and push it to the database\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>If we now query our Neo4j database with </p> <pre><code>MATCH (bs:bookshelf) return bs.material\n</code></pre> <p>we get</p> <pre><code>[\n{\n\"bs.material\": \"wood\"\n}\n]\n</code></pre> <p>as a return value. we added a new property to the node.</p>"},{"location":"use_transformers/#compact-variant","title":"Compact variant","text":"<p>Lets tidy up our code.</p> <p>The same code we just wrote can also look like this:</p> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2graph, Transformer, NodeTrans\ndata = {\n\"bookshelf\": {\n\"Genre\": \"Explaining the world\",\n\"books\": [\n{\n\"title\": \"Fine-structure constant - God set our instance a fine environment variable\",\n},\n{\n\"title\": \"Goodhart's law - Better benchmark nothing, stupid!\",\n},\n],\n}\n}\nd2g = Dict2graph()\nd2g.add_transformation(\nTransformer.match_nodes(\"bookshelf\").do(NodeTrans.AddProperty({\"material\": \"wood\"}))\n)\nd2g.parse(data)\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>this is much more compact and depending on your taste more readable. But its just a style question. Choice is yours. But...</p>"},{"location":"use_transformers/#order-matters","title":"Order matters!","text":"<p>The sequence of your transformers matters. Any transformation is passed to the next transformator.</p> <p>Lets compare to very similar code snippets. The only differentce will be the sequence of our transformators.</p> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2graph, Transformer, NodeTrans\ndata = {\"bookshelf\": {\"Genre\": \"Explaining the world\"}}\nd2g = Dict2graph()\nd2g.add_transformation(\n[\nTransformer.match_nodes(\"bookshelf\").do(NodeTrans.AddProperty({\"mtr\": \"wood\"})),\nTransformer.match_nodes(\"bookshelf\").do(\nNodeTrans.OverridePropertyName(\"mtr\", \"material\")\n),\n]\n)\nd2g.parse(data)\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>The result of </p> <pre><code>MATCH (bs:bookshelf) return bs\n</code></pre> <p>will be </p> <pre><code>\u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n\u2502\"bs\"                                              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502{\"material\":\"wood\",\"Genre\":\"Explaining the world\"}\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Now lets flip the order of our transformators:</p> <pre><code>from neo4j import GraphDatabase\nfrom dict2graph import Dict2graph, Transformer, NodeTrans\ndata = {\"bookshelf\": {\"Genre\": \"Explaining the world\"}}\nd2g = Dict2graph()\nd2g.add_transformation(\n[\nTransformer.match_nodes(\"bookshelf\").do(\nNodeTrans.OverridePropertyName(\"mtr\", \"material\")\n),\nTransformer.match_nodes(\"bookshelf\").do(NodeTrans.AddProperty({\"mtr\": \"wood\"})),\n]\n)\nd2g.parse(data)\nNEO4J_DRIVER = GraphDatabase.driver(\"neo4j://localhost\")\nd2g.create(NEO4J_DRIVER)\n</code></pre> <p>The result of </p> <pre><code>MATCH (bs:bookshelf) return bs\n</code></pre> <p>will be </p> <pre><code>\u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n\u2502\"bs\"                                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502{\"mtr\":\"wood\",\"Genre\":\"Explaining the world\"}\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You see in the first case we added the new property first and then renamed it.</p> <p>In the second case we tried to rename it first. but it was not available yet, as the node Transformator <code>AddProperty</code> came after <code>OverridePropertyName</code></p> <p>So keep that in mind when chaining transformations.</p>"},{"location":"api/api_dict2graph/","title":"Dict2Graph","text":""},{"location":"api/api_dict2graph/#dict2graph.Dict2graph","title":"<code>dict2graph.Dict2graph</code>","text":"Source code in <code>dict2graph/dict2graph.py</code> <pre><code>class Dict2graph:\n# Replacement strings {ITEM_PRIMARY_LABEL} and {ITEM_LABELs} are available\nlist_hub_additional_labels: List[str] = [\"ListHub\"]\nlist_item_additional_labels: List[str] = [\"ListItem\"]\nlist_hub_id_property_name: str = \"id\"\nlist_item_relation_index_property_name: str = \"_list_item_index\"\nsimple_list_item_data_property_name: str = \"_list_item_data\"\nroot_node_default_labels: List[str] = [\"Dict2GraphRoot\"]\nroot_node_default_id_property_name = \"id\"\nempty_node_default_id_property_name = \"id\"\ndef __init__(\nself,\ncreate_ids_for_empty_nodes: bool = True,\ninterpret_single_props_as_labels: bool = True,\n):\n\"\"\"Main class for dict2graph. Instance Dict2graph to get access to the API.\n        Usage:\n        ```python\n        from dict2graph import Dict2graph\n        d2g = Dict2Graph()\n        ```\n        Args:\n            create_ids_for_empty_nodes (bool, optional): When input dicts results in empty 'hub' nodes, this will create artificially key properties based on the child data. The key will be deterministic . Defaults to True.\n            interpret_single_props_as_labels (bool, optional): When having object with a single property like `{\"animal\":{\"name\":\"dog\"}}` `animal` will be interpreted as label. If set to false \"animal\" will result in an extra Node. Defaults to True.\n        \"\"\"\nself.create_ids_for_empty_nodes = create_ids_for_empty_nodes\n# Todo: \"interpret_single_props_as_labels\" should be a regualr NodeTransformer instead of a class param\nself.interpret_single_props_as_labels = interpret_single_props_as_labels\nself._node_cache: List[Node] = []\nself._node_cache_feeder: List[Node] = []\nself._rel_cache: List[Relation] = []\nself._rel_cache_feeder: List[Node] = []\nself._nodeSets: Dict[Tuple, NodeSet] = {}\nself._relSets: Dict[Tuple, RelationshipSet] = {}\nself.node_transformators: List[_NodeTransformerBase] = []\nself.relation_transformators: List[_RelationTransformerBase] = []\ndef add_transformation(\nself,\ntransformator: Union[\n_NodeTransformerBase,\n_RelationTransformerBase,\nList[Union[_NodeTransformerBase, _RelationTransformerBase]],\n],\n):\n\"\"\"Add a [`Transformers`](dict2graph/use_transformers.md) to the Dict2Graph instance.\n        Transformers can re-model your graph befor writing it to a Neo4h database.\n        usage:\n        ```python\n        from dict2graph import Dict2graph, Transformer, NodeTrans\n        d2g = Dict2Graph()\n        d2g.add_transformation(\n            Transformer.match_nodes(\"article\").do(NodeTrans.OverrideLabel(\"book\"))\n        )\n        ```\n        Args:\n            transformator (Union[ _NodeTransformerBase, _RelationTransformerBase, List[Union[_NodeTransformerBase, _RelationTransformerBase]], ]): A list or single instance of a Transformer\n        \"\"\"\nif isinstance(transformator, list):\nfor trans in transformator:\nself.add_transformation(trans)\nreturn\nif self._get_transformer_class(transformator) == _NodeTransformerBase:\nself.add_node_transformation(transformator)\nelif self._get_transformer_class(transformator) == _RelationTransformerBase:\nself.add_relation_transformation(transformator)\nelse:\nraise ValueError(\nf\"Expected transformer of subclass '{_NodeTransformerBase}' or '{_RelationTransformerBase}', got '{transformator.__class__}' (child of '{transformator.__class__.__bases__}')\"\n)\ndef _get_transformer_class(\nself, transformator: Union[_NodeTransformerBase, _RelationTransformerBase]\n) -&gt; Union[Type[_NodeTransformerBase], type[_RelationTransformerBase]]:\nif issubclass(transformator.__class__, _NodeTransformerBase) and issubclass(\ntransformator.__class__, _RelationTransformerBase\n):\n# We got a generic transformator. we have to look at the matcher to determine the transformator type.\nif isinstance(transformator.matcher, Transformer.RelTransformerMatcher):\nreturn _RelationTransformerBase\nelif isinstance(transformator.matcher, Transformer.NodeTransformerMatcher):\nreturn _NodeTransformerBase\nelif issubclass(transformator.__class__, _NodeTransformerBase):\nreturn _NodeTransformerBase\nelif issubclass(transformator.__class__, _RelationTransformerBase):\nreturn _RelationTransformerBase\ndef add_node_transformation(\nself, transformator: Union[_NodeTransformerBase, List[_NodeTransformerBase]]\n):\nif isinstance(transformator, list):\nfor trans in transformator:\nself.add_node_transformation(trans)\nreturn\nif transformator.matcher is None:\nraise ValueError(f\"No matcher added to {transformator}\")\nif not issubclass(transformator.__class__, _NodeTransformerBase):\nraise ValueError(\nf\"Expected transformer of subclass '{_NodeTransformerBase}', got '{transformator.__class__}' (child of '{transformator.__class__.__bases__}').\\nMaybe you wanted to use function `Dict2graph.add_relation_transformation()` instead of `add_node_transformation`?\"\n)\nelif transformator.matcher.__class__ != Transformer.NodeTransformerMatcher:\nraise ValueError(\nf\"Expected transformer matcher of class '{Transformer.NodeTransformerMatcher}', got '{transformator.matcher.__class__}'.\\nMaybe you accidentally added a relationship matcher instead of a node matcher (`match_nodes()` vs. `match_rels()`) while using `Dict2graph.add_node_transformation()`?\"\n)\nelse:\ntransformator.d2g = self\nself.node_transformators.append(transformator)\ndef add_relation_transformation(\nself,\ntransformator: Union[_RelationTransformerBase, List[_RelationTransformerBase]],\n):\nif isinstance(transformator, list):\nfor trans in transformator:\nself.add_relation_transformation(trans)\nreturn\nelif not issubclass(transformator.__class__, _RelationTransformerBase):\nraise ValueError(\nf\"Expected transformer of subclass '{_RelationTransformerBase}', got '{transformator.__class__}' (child of '{transformator.__class__.__bases__}').\\nMaybe you wanted to use function `Dict2graph.add_node_transformation()` instead of `add_relation_transformation`?\"\n)\nelif transformator.matcher.__class__ != Transformer.RelTransformerMatcher:\nraise ValueError(\nf\"Expected transformer matcher of class '{Transformer.RelTransformerMatcher}', got '{transformator.matcher.__class__}'.\\nMaybe you accidentally added a node matcher instead of a relationship matcher (`match_rels()` vs. `match_nodes()`) while using `Dict2graph.add_relation_transformation()`?\"\n)\nelse:\nself.relation_transformators.append(transformator)\ndef parse(\nself, data: Dict, root_node_labels: Union[str, List[str]] = None\n) -&gt; \"Dict2graph\":\nif root_node_labels is None:\nif isinstance(data, dict) and len(data.keys()) == 1:\n# we only have one key and therefore only one Node on the top-/root-level. We dont need a root Node to connect the toplevels nodes.\nroot_node_labels = [list(data.keys())[0]]\ndata = data[root_node_labels[0]]\nelse:\nroot_node_labels = self.root_node_default_labels\nif isinstance(root_node_labels, str):\nroot_node_labels = [root_node_labels]\nif isinstance(data, str):\ndata_obj = json.loads(data)\nelse:\ndata_obj = data\nif not isinstance(data_obj, dict) and not isinstance(data_obj, list):\nraise ValueError(\n\"Expected json compatible object like a dict or list. got {}\".format(\ntype(data_obj).__name__\n)\n)\nif isinstance(data_obj, dict):\nroot_node = self._parse_traverse_dict_fragment(\nlabels=root_node_labels, data=data_obj, parent_node=None\n)\nelif isinstance(data_obj, list):\nroot_node = self._parse_traverse_list_fragment(\nlabels=root_node_labels, data=data_obj, parent_node=None\n)\nself._prepare_root_node(root_node)\nself._flush_cache()\nreturn self\ndef merge(self, graph: Union[Graph, Driver]):\nfor nodes in self._nodeSets.values():\nnodes.merge(graph)\nfor rels in self._relSets.values():\nrels.merge(graph)\ndef create(self, graph: Union[Graph, Driver]):\nfor nodes in self._nodeSets.values():\nnodes.create(graph)\nfor rels in self._relSets.values():\nrels.create(graph)\ndef _prepare_root_node(self, node: Node):\nnode.is_root_node = True\nif len(node.keys()) == 0:\nnode[self.root_node_default_id_property_name] = node.get_hash(\ninclude_children_data=True\n)\nnode.merge_property_keys = [self.root_node_default_id_property_name]\ndef _parse_traverse_dict_fragment(\nself, data: Dict, parent_node: Node, labels: List[str] = None\n) -&gt; Node:\nnew_node = Node(labels=labels, source_data=data, parent_node=parent_node)\nnew_child_nodes: List[Node] = []\nnew_rels: List[Relation] = []\nfor key, val in data.items():\nif self._is_basic_attribute_type(val):\n# value is a simple type. attach as property to node\nnew_node[key] = val\nelse:\n# value is dict or list in itself and therefore one or multiple child nodes\nr = None\nn = None\nif isinstance(val, dict):\nif self._is_named_obj(val):\nn = self._parse_traverse_dict_fragment(\nlabels=list(val.keys()),\ndata=val[list(val.keys())[0]],\nparent_node=new_node,\n)\nr = Relation(start_node=new_node, end_node=n, relation_type=key)\nelse:\nn = self._parse_traverse_dict_fragment(\nlabels=[key], data=val, parent_node=new_node\n)\nelif isinstance(val, list):\nn = self._parse_traverse_list_fragment(\nlabels=[key], data=val, parent_node=new_node\n)\nif n is not None:\nnew_child_nodes.append(n)\nif r is None:\nr = Relation(\nstart_node=new_node,\nend_node=n,\n)\nnew_rels.append(r)\nself._node_cache.append(new_node)\nself._rel_cache.extend(new_rels)\nreturn new_node\ndef _parse_traverse_list_fragment(\nself, labels: List[str], parent_node: Node, data: Dict\n) -&gt; Node:\n# create/set list root node. this is the node on which the list items will attach to\n# the parent_node is the default root\nlist_root_hub_node: Node = Node(\nlabels=labels,\nsource_data=data,\nparent_node=parent_node,\n)\nself._set_list_root_hub_node_labels(list_root_hub_node)\nlist_root_hub_node.is_list_list_hub = True\nself._node_cache.append(list_root_hub_node)\n# parse nodes\nnew_list_item_nodes: List[Node] = []\nfor index, obj in enumerate(data):\nif self._is_basic_attribute_type(obj):\nn = Node(labels, source_data=obj, parent_node=list_root_hub_node)\nn[self.simple_list_item_data_property_name] = obj\nself._node_cache.append(n)\nnew_list_item_nodes.append(n)\nelif self._is_named_obj(obj):\nobj_label = list(obj.keys())[0]\nobj_data = obj[obj_label]\nnew_list_item_nodes.append(\nself._parse_traverse_dict_fragment(\nlabels=obj_label, data=obj_data, parent_node=list_root_hub_node\n)\n)\nelif isinstance(obj, dict):\nnew_list_item_nodes.append(\nself._parse_traverse_dict_fragment(\nlabels=labels, data=obj, parent_node=list_root_hub_node\n)\n)\nelif isinstance(obj, list):\nnew_list_item_nodes.append(\nself._parse_traverse_list_fragment(\nlabels=labels, data=obj, parent_node=list_root_hub_node\n)\n)\n# create relations to list root node\nchild_ids: List[str] = []\nfor index, node in enumerate(new_list_item_nodes):\nif node is None:\ncontinue\nself._set_list_item_node_labels(node)\nnode.is_list_list_item = True\nchild_ids.append(node.id)\nr = Relation(\nstart_node=list_root_hub_node,\nend_node=node,\n)\nr[self.list_item_relation_index_property_name] = index\nnode.parent_node = list_root_hub_node\nself._rel_cache.append(r)\n#\nlist_root_hub_node[\nself.list_hub_id_property_name\n] = list_root_hub_node.get_hash(include_children_data=True)\nlist_root_hub_node.merge_property_keys = [self.list_hub_id_property_name]\nreturn list_root_hub_node\ndef _is_empty(self, val):\nif not val:\nreturn True\nif isinstance(val, str) and val.upper() in [\"\", \"NULL\"]:\nreturn True\nreturn False\ndef _is_basic_attribute_type(self, val):\nif isinstance(val, (str, int, float, bool)):\nreturn True\nelse:\nreturn False\ndef _is_named_obj(self, data: Dict):\n\"\"\"If an object is a one-keyd dict on the first layer and there is a dict behind this key,\n        we determine that this one key is the label/type and the inner dict are the props\n        Args:\n            data (List): _description_\n        Returns:\n            _type_: _description_\n        \"\"\"\n# {\"person\":{\"name\":\"tom\",\"lastname\":\"schilling\"}} -&gt; we know its a person\n# {\"name\":\"tom\",\"lastname\":\"schilling\"} -&gt; Could be a person or a lama\n# {\"client\":{\"name\":\"tom\",\"lastname\":\"schilling\"},\"cert\":\"yes\"} -&gt; -&gt; Could be a person or a computer\nif not self.interpret_single_props_as_labels:\nreturn False\nif (\nisinstance(data, dict)\nand len(data.keys()) == 1\nand isinstance(data[list(data.keys())[0]], dict)\n):\nreturn True\nreturn False\ndef _set_list_root_hub_node_labels(self, node: Node) -&gt; str:\naddi_labels = [\nl.replace(\"{{ITEM_PRIMARY_LABEL}}\", node.primary_label)\nfor l in self.list_hub_additional_labels\n]\naddi_labels = [\nl.replace(\"{{ITEM_LABELS}}\", \"_\".join(node.primary_label))\nfor l in addi_labels\n]\nnode.labels = node.labels + addi_labels\ndef _set_list_item_node_labels(self, node: Node) -&gt; str:\nnode.labels = node.labels + self.list_item_additional_labels\ndef _manifest_node_from_cache(self, cached_node: Node):\nnode_set: NodeSet = self._get_or_create_nodeSet(cached_node)\nif self.create_ids_for_empty_nodes and cached_node.id is None:\ncached_node[\nself.empty_node_default_id_property_name\n] = cached_node.get_hash(include_children_data=True)\ncached_node.merge_property_keys = [self.empty_node_default_id_property_name]\nnode_set.add_node(cached_node)\ndef _get_or_create_nodeSet(self, node: Node) -&gt; NodeSet:\nnode_type_fingerprint = frozenset(node.labels)\nif node_type_fingerprint not in self._nodeSets:\nself._nodeSets[node_type_fingerprint] = NodeSet(\nlabels=node.labels,\nmerge_keys=node.merge_property_keys\nif node.merge_property_keys\nelse list(node.keys()),\n)\nreturn self._nodeSets[node_type_fingerprint]\ndef _manifest_rel_from_cache(self, cached_relation: Relation):\nrel_set: RelationshipSet = self._get_or_create_relSet(cached_relation)\nrel_set.add_relationship(\nstart_node_properties=cached_relation.start_node,\nend_node_properties=cached_relation.end_node,\nproperties=cached_relation,\n)\ndef _get_or_create_relSet(self, relation: Relation) -&gt; RelationshipSet:\nrel_id = (\nfrozenset(relation.start_node.labels),\nfrozenset(relation.start_node.merge_property_keys),\nrelation.relation_type,\nfrozenset(relation.end_node.labels),\nfrozenset(relation.end_node.merge_property_keys),\n)\nif rel_id not in self._relSets:\nself._relSets[rel_id] = RelationshipSet(\nrel_type=relation.relation_type,\nstart_node_labels=relation.start_node.labels,\nend_node_labels=relation.end_node.labels,\nstart_node_properties=relation.start_node.merge_property_keys,\nend_node_properties=relation.end_node.merge_property_keys,\n)\nreturn self._relSets[rel_id]\ndef add_node_to_cache(self, node: Node):\nself._node_cache_feeder.append(node)\ndef add_rel_to_cache(self, rel: Relation):\nself._rel_cache_feeder.append(rel)\ndef _flush_cache(self):\nself._feed_cache_with_new_nodes_and_rels()\nself._run_transformations()\nfor node in self._node_cache:\nif not node.deleted:\nself._manifest_node_from_cache(node)\nfor rel in self._rel_cache:\nif not rel.deleted:\nself._manifest_rel_from_cache(rel)\nself._node_cache = []\nself._rel_cache = []\ndef _run_transformations(self):\nfor trans in self.node_transformators:\nfor node in self._node_cache:\ntrans._run_node_match_and_transform(node)\nself._feed_cache_with_new_nodes_and_rels()\nfor trans in self.relation_transformators:\nfor rel in self._rel_cache:\ntrans._run_rel_match_and_transform(rel)\nself._feed_cache_with_new_nodes_and_rels()\ndef _feed_cache_with_new_nodes_and_rels(self):\nself._node_cache.extend(self._node_cache_feeder)\nself._node_cache_feeder = []\nself._rel_cache.extend(self._rel_cache_feeder)\nself._rel_cache_feeder = []\n</code></pre>"},{"location":"api/api_dict2graph/#dict2graph.dict2graph.Dict2graph.__init__","title":"<code>__init__(create_ids_for_empty_nodes=True, interpret_single_props_as_labels=True)</code>","text":"<p>Main class for dict2graph. Instance Dict2graph to get access to the API. Usage: <pre><code>from dict2graph import Dict2graph\nd2g = Dict2Graph()\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>create_ids_for_empty_nodes</code> <code>bool</code> <p>When input dicts results in empty 'hub' nodes, this will create artificially key properties based on the child data. The key will be deterministic . Defaults to True.</p> <code>True</code> <code>interpret_single_props_as_labels</code> <code>bool</code> <p>When having object with a single property like <code>{\"animal\":{\"name\":\"dog\"}}</code> <code>animal</code> will be interpreted as label. If set to false \"animal\" will result in an extra Node. Defaults to True.</p> <code>True</code> Source code in <code>dict2graph/dict2graph.py</code> <pre><code>def __init__(\nself,\ncreate_ids_for_empty_nodes: bool = True,\ninterpret_single_props_as_labels: bool = True,\n):\n\"\"\"Main class for dict2graph. Instance Dict2graph to get access to the API.\n    Usage:\n    ```python\n    from dict2graph import Dict2graph\n    d2g = Dict2Graph()\n    ```\n    Args:\n        create_ids_for_empty_nodes (bool, optional): When input dicts results in empty 'hub' nodes, this will create artificially key properties based on the child data. The key will be deterministic . Defaults to True.\n        interpret_single_props_as_labels (bool, optional): When having object with a single property like `{\"animal\":{\"name\":\"dog\"}}` `animal` will be interpreted as label. If set to false \"animal\" will result in an extra Node. Defaults to True.\n    \"\"\"\nself.create_ids_for_empty_nodes = create_ids_for_empty_nodes\n# Todo: \"interpret_single_props_as_labels\" should be a regualr NodeTransformer instead of a class param\nself.interpret_single_props_as_labels = interpret_single_props_as_labels\nself._node_cache: List[Node] = []\nself._node_cache_feeder: List[Node] = []\nself._rel_cache: List[Relation] = []\nself._rel_cache_feeder: List[Node] = []\nself._nodeSets: Dict[Tuple, NodeSet] = {}\nself._relSets: Dict[Tuple, RelationshipSet] = {}\nself.node_transformators: List[_NodeTransformerBase] = []\nself.relation_transformators: List[_RelationTransformerBase] = []\n</code></pre>"},{"location":"api/api_dict2graph/#dict2graph.dict2graph.Dict2graph.add_transformation","title":"<code>add_transformation(transformator)</code>","text":"<p>Add a <code>Transformers</code> to the Dict2Graph instance. Transformers can re-model your graph befor writing it to a Neo4h database. usage: <pre><code>from dict2graph import Dict2graph, Transformer, NodeTrans\nd2g = Dict2Graph()\nd2g.add_transformation(\nTransformer.match_nodes(\"article\").do(NodeTrans.OverrideLabel(\"book\"))\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>transformator</code> <code>Union[_NodeTransformerBase, _RelationTransformerBase, List[Union[_NodeTransformerBase, _RelationTransformerBase]]]</code> <p>A list or single instance of a Transformer</p> required Source code in <code>dict2graph/dict2graph.py</code> <pre><code>def add_transformation(\nself,\ntransformator: Union[\n_NodeTransformerBase,\n_RelationTransformerBase,\nList[Union[_NodeTransformerBase, _RelationTransformerBase]],\n],\n):\n\"\"\"Add a [`Transformers`](dict2graph/use_transformers.md) to the Dict2Graph instance.\n    Transformers can re-model your graph befor writing it to a Neo4h database.\n    usage:\n    ```python\n    from dict2graph import Dict2graph, Transformer, NodeTrans\n    d2g = Dict2Graph()\n    d2g.add_transformation(\n        Transformer.match_nodes(\"article\").do(NodeTrans.OverrideLabel(\"book\"))\n    )\n    ```\n    Args:\n        transformator (Union[ _NodeTransformerBase, _RelationTransformerBase, List[Union[_NodeTransformerBase, _RelationTransformerBase]], ]): A list or single instance of a Transformer\n    \"\"\"\nif isinstance(transformator, list):\nfor trans in transformator:\nself.add_transformation(trans)\nreturn\nif self._get_transformer_class(transformator) == _NodeTransformerBase:\nself.add_node_transformation(transformator)\nelif self._get_transformer_class(transformator) == _RelationTransformerBase:\nself.add_relation_transformation(transformator)\nelse:\nraise ValueError(\nf\"Expected transformer of subclass '{_NodeTransformerBase}' or '{_RelationTransformerBase}', got '{transformator.__class__}' (child of '{transformator.__class__.__bases__}')\"\n)\n</code></pre>"},{"location":"api/api_node/","title":"Node","text":""},{"location":"api/api_node/#dict2graph.Node","title":"<code>dict2graph.Node</code>","text":"<p>         Bases: <code>dict</code></p> <p>Represantation of a property-graph node</p> Source code in <code>dict2graph/node.py</code> <pre><code>class Node(dict):\n\"\"\"Represantation of a property-graph node\"\"\"\ndef __init__(\nself,\nlabels: List[str],\nsource_data: Union[Dict, List, str, int],\nparent_node: Node,\n**kwargs,\n):\nif isinstance(labels, str):\nlabels = [labels]\nself._labels: List[str] = labels\nself.parent_node: Node = parent_node\nself.source_data: Dict = source_data\nself._merge_property_keys: List[str] = None\nself.update(**kwargs)\nself._relations: List[Relation] = []\nself.is_list_list_hub: bool = False\nself.is_list_list_item: bool = False\nself.is_root_node: bool = False\nself.deleted = False\n@property\ndef id(self) -&gt; str:\n\"\"\"Deterministic identifier of the Node.\n        Will change if the nodes changes merge properties change.\n        The `id` is for internal use will not end up in the Neo4j graph.\n        Returns:\n            str: The id. A hex number string\n        \"\"\"\nif self.merge_property_keys and len(self.merge_property_keys) == 1:\nreturn self[self.merge_property_keys[0]]\nelif len(self.keys()) == 0:\nreturn None\nelse:\nreturn hashlib.md5(\nbytes(\njson.dumps([self[key] for key in self.merge_property_keys]),\n\"utf-8\",\n),\n).hexdigest()\n@property\ndef labels(self) -&gt; List[str]:\n\"\"\"All labels of the node as a list\n        Returns:\n            List[str]: Labels\n        \"\"\"\nreturn self._labels\n@labels.setter\ndef labels(self, val: List[str]):\nif isinstance(val, list):\nself._labels = val\nelse:\nraise ValueError(f\"Labels must be provided as list, got {val}\")\n@property\ndef primary_label(self) -&gt; str:\n\"\"\"The label to visually represent the node.\n        Returns:\n            str: the primary label as a string\n        \"\"\"\nreturn self._labels[0] if self.labels else None\n@primary_label.setter\ndef primary_label(self, val: str):\nif val in self._labels:\nself._labels.insert(0, self._labels.pop(self._labels.index(val)))\nelse:\nself._labels.insert(0, val)\n@property\ndef merge_property_keys(self) -&gt; List[str]:\n\"\"\"When merging to Neo4j instead of creating, these properties will be taken into account.\n        Similar to primary keys in the SQL World.\n        Defaults include all properties of the node.\n        Returns:\n            List[str]: The\n        \"\"\"\nreturn (\nself._merge_property_keys\nif self._merge_property_keys\nelse list(self.keys())\n)\n@merge_property_keys.setter\ndef merge_property_keys(self, primary_props: List[str]):\nself._merge_property_keys = primary_props\ndef get_hash(\nself,\ninclude_properties: List[str] = None,\ninclude_merge_properties: bool = True,\ninclude_other_properties: bool = True,\ninclude_parent_properties: bool = False,\ninclude_children_properties: bool = False,\ninclude_children_data: bool = False,\n) -&gt; str:\n\"\"\"Generate a deterministic hash of the node.\n        Optionaly this hahs can include data from child or parents to distinguish from nodes with equal properties.\n        Args:\n            include_properties (List[str], optional): A list of properties to include in the hash. Defaults to None.\n            include_merge_properties (bool, optional): Set True to also include merge properties. Defaults to True.\n            include_other_properties (bool, optional): Set True to also include non merge properties. Defaults to True.\n            include_parent_properties (bool, optional): Set True to also include merge properties of parent nodes. Defaults to False.\n            include_children_properties (bool, optional): Set True to also include merge properties of direct child nodes. Defaults to False.\n            include_children_data (bool, optional): Set True to also include all properties of the child tree. Defaults to False.\n        Returns:\n            str: A hex number string\n        \"\"\"\nif include_properties is None:\ninclude_properties = []\nhash_source_values = []\nif include_properties:\nhash_source_values.extend(\n[{key: val} for key, val in self.items() if key in include_properties]\n)\nif include_merge_properties:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.items()\nif key in self.merge_property_keys + include_properties\n]\n)\nif include_other_properties:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.items()\nif key not in self.merge_property_keys + include_properties\n]\n)\nif include_parent_properties and self.parent_node is not None:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.parent_node.items()\nif key not in self.parent_node.merge_property_keys\n]\n)\nif include_children_properties:\nfor child in self.child_nodes:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in child.items()\nif key not in child.merge_property_keys\n]\n)\nif include_children_data:\nfor child in self.child_nodes:\nhash_source_values.append(child.source_data)\nreturn hashlib.md5(\nbytes(\njson.dumps(hash_source_values),\n\"utf-8\",\n),\n).hexdigest()\n@property\ndef relations(self) -&gt; List[Relation]:\n\"\"\"All relationships a node is connected with\n        Returns:\n            List[Relation]: A list of relations\n        \"\"\"\nreturn self._relations\n@relations.setter\ndef relations(self, relations: List[Relation]):\nself._relations = [rel for rel in relations if not rel.deleted]\n@property\ndef outgoing_relations(self) -&gt; List[Relation]:\n\"\"\"All outgoing relationships a node is connected with\n        Returns:\n            List[Relation]: A list of relations\n        \"\"\"\nreturn [rel for rel in self.relations if rel.start_node == self]\n@property\ndef incoming_relations(self) -&gt; List[Relation]:\n\"\"\"All incoming relationships a node is connected with\n        Returns:\n            List[Relation]: A list of relations\n        \"\"\"\nreturn [rel for rel in self.relations if rel.end_node == self]\n@property\ndef child_nodes(self) -&gt; List[Node]:\n\"\"\"All nodes of outgoing relationshipsets\n        Returns:\n            List[Node]: A list of Nodes\n        \"\"\"\nreturn [rel.end_node for rel in self.outgoing_relations]\ndef __str__(self):\nreturn f\"({':'.join(self.labels)}{super().__str__()})\"\n</code></pre>"},{"location":"api/api_node/#dict2graph.node.Node.child_nodes","title":"<code>child_nodes: List[Node]</code>  <code>property</code>","text":"<p>All nodes of outgoing relationshipsets</p> <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[Node]: A list of Nodes</p>"},{"location":"api/api_node/#dict2graph.node.Node.id","title":"<code>id: str</code>  <code>property</code>","text":"<p>Deterministic identifier of the Node. Will change if the nodes changes merge properties change. The <code>id</code> is for internal use will not end up in the Neo4j graph.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The id. A hex number string</p>"},{"location":"api/api_node/#dict2graph.node.Node.incoming_relations","title":"<code>incoming_relations: List[Relation]</code>  <code>property</code>","text":"<p>All incoming relationships a node is connected with</p> <p>Returns:</p> Type Description <code>List[Relation]</code> <p>List[Relation]: A list of relations</p>"},{"location":"api/api_node/#dict2graph.node.Node.labels","title":"<code>labels: List[str]</code>  <code>writable</code> <code>property</code>","text":"<p>All labels of the node as a list</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Labels</p>"},{"location":"api/api_node/#dict2graph.node.Node.merge_property_keys","title":"<code>merge_property_keys: List[str]</code>  <code>writable</code> <code>property</code>","text":"<p>When merging to Neo4j instead of creating, these properties will be taken into account. Similar to primary keys in the SQL World.</p> <p>Defaults include all properties of the node.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The</p>"},{"location":"api/api_node/#dict2graph.node.Node.outgoing_relations","title":"<code>outgoing_relations: List[Relation]</code>  <code>property</code>","text":"<p>All outgoing relationships a node is connected with</p> <p>Returns:</p> Type Description <code>List[Relation]</code> <p>List[Relation]: A list of relations</p>"},{"location":"api/api_node/#dict2graph.node.Node.primary_label","title":"<code>primary_label: str</code>  <code>writable</code> <code>property</code>","text":"<p>The label to visually represent the node.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the primary label as a string</p>"},{"location":"api/api_node/#dict2graph.node.Node.relations","title":"<code>relations: List[Relation]</code>  <code>writable</code> <code>property</code>","text":"<p>All relationships a node is connected with</p> <p>Returns:</p> Type Description <code>List[Relation]</code> <p>List[Relation]: A list of relations</p>"},{"location":"api/api_node/#dict2graph.node.Node.get_hash","title":"<code>get_hash(include_properties=None, include_merge_properties=True, include_other_properties=True, include_parent_properties=False, include_children_properties=False, include_children_data=False)</code>","text":"<p>Generate a deterministic hash of the node. Optionaly this hahs can include data from child or parents to distinguish from nodes with equal properties.</p> <p>Parameters:</p> Name Type Description Default <code>include_properties</code> <code>List[str]</code> <p>A list of properties to include in the hash. Defaults to None.</p> <code>None</code> <code>include_merge_properties</code> <code>bool</code> <p>Set True to also include merge properties. Defaults to True.</p> <code>True</code> <code>include_other_properties</code> <code>bool</code> <p>Set True to also include non merge properties. Defaults to True.</p> <code>True</code> <code>include_parent_properties</code> <code>bool</code> <p>Set True to also include merge properties of parent nodes. Defaults to False.</p> <code>False</code> <code>include_children_properties</code> <code>bool</code> <p>Set True to also include merge properties of direct child nodes. Defaults to False.</p> <code>False</code> <code>include_children_data</code> <code>bool</code> <p>Set True to also include all properties of the child tree. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A hex number string</p> Source code in <code>dict2graph/node.py</code> <pre><code>def get_hash(\nself,\ninclude_properties: List[str] = None,\ninclude_merge_properties: bool = True,\ninclude_other_properties: bool = True,\ninclude_parent_properties: bool = False,\ninclude_children_properties: bool = False,\ninclude_children_data: bool = False,\n) -&gt; str:\n\"\"\"Generate a deterministic hash of the node.\n    Optionaly this hahs can include data from child or parents to distinguish from nodes with equal properties.\n    Args:\n        include_properties (List[str], optional): A list of properties to include in the hash. Defaults to None.\n        include_merge_properties (bool, optional): Set True to also include merge properties. Defaults to True.\n        include_other_properties (bool, optional): Set True to also include non merge properties. Defaults to True.\n        include_parent_properties (bool, optional): Set True to also include merge properties of parent nodes. Defaults to False.\n        include_children_properties (bool, optional): Set True to also include merge properties of direct child nodes. Defaults to False.\n        include_children_data (bool, optional): Set True to also include all properties of the child tree. Defaults to False.\n    Returns:\n        str: A hex number string\n    \"\"\"\nif include_properties is None:\ninclude_properties = []\nhash_source_values = []\nif include_properties:\nhash_source_values.extend(\n[{key: val} for key, val in self.items() if key in include_properties]\n)\nif include_merge_properties:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.items()\nif key in self.merge_property_keys + include_properties\n]\n)\nif include_other_properties:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.items()\nif key not in self.merge_property_keys + include_properties\n]\n)\nif include_parent_properties and self.parent_node is not None:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in self.parent_node.items()\nif key not in self.parent_node.merge_property_keys\n]\n)\nif include_children_properties:\nfor child in self.child_nodes:\nhash_source_values.extend(\n[\n{key: val}\nfor key, val in child.items()\nif key not in child.merge_property_keys\n]\n)\nif include_children_data:\nfor child in self.child_nodes:\nhash_source_values.append(child.source_data)\nreturn hashlib.md5(\nbytes(\njson.dumps(hash_source_values),\n\"utf-8\",\n),\n).hexdigest()\n</code></pre>"},{"location":"api/api_relation/","title":"Relation","text":""},{"location":"api/api_relation/#dict2graph.Relation","title":"<code>dict2graph.Relation</code>","text":"<p>         Bases: <code>dict</code></p> <p>Represantation of a property-graph relationship</p> Source code in <code>dict2graph/relation.py</code> <pre><code>class Relation(dict):\n\"\"\"Represantation of a property-graph relationship\"\"\"\ndef __init__(\nself, start_node: Node, end_node: Node, relation_type: str = None, **kwargs\n):\n\"\"\"Create a new relationship\n        Args:\n            start_node (Node): The node from which the relationship will start\n            end_node (Node): The node to which the relationship will go to\n            relation_type (str, optional): The name if the relation. Defaults to None.\n            **kwargs (Any, optional): Any further properties of this relationship. Defaults to None.\n        \"\"\"\nself._relation_type = relation_type\nself._start_node = None\nself._end_node = None\nself.start_node = start_node\nself.end_node = end_node\nself._origin_relation_type: str = relation_type\nself.deleted = False\nself.update(**kwargs)\n@property\ndef relation_type(self) -&gt; str:\n\"\"\"The name of the relationship.\n        As in [Neo4j Relation Type](https://neo4j.com/docs/getting-started/current/appendix/graphdb-concepts/#graphdb-relationship-type)\n        Defaults to a string with following structure:\n        `&lt;start node first label&gt;_HAS_&lt;end_node_first_label&gt;`\n        Returns:\n            str: The relationship type as str\n        \"\"\"\nif self._relation_type:\nreturn self._relation_type\nelif self.start_node is not None and self.end_node is not None:\nif (\nself.start_node.is_list_list_hub\n# and not self.start_node.is_root_node\n):\nreturn f\"{self.start_node.primary_label}_LIST_HAS_{self.end_node.primary_label}\"\nelse:\nreturn (\nf\"{self.start_node.primary_label}_HAS_{self.end_node.primary_label}\"\n)\nelse:\nreturn \"NON_NAMED_REL\"\n@relation_type.setter\ndef relation_type(self, value: str) -&gt; str:\nself._relation_type = value\n@property\ndef start_node(self) -&gt; Node:\n\"\"\"The node from which the relationship is originating\n        Returns:\n            Node: The start node as a [Dict2Graph.Node](/api/api_node) instance\n        \"\"\"\nreturn self._start_node\n@start_node.setter\ndef start_node(self, node: Node):\nif self._start_node:\n# relation changed. we need to remove the relation form the old node\nself._start_node.relations.remove(self)\nnode.relations.append(self)\nself._start_node = node\n@property\ndef end_node(self) -&gt; Node:\n\"\"\"The target node of the relationship\n        Returns:\n            Node: The end node as a [Dict2Graph.Node](/api/api_node) instance\n        \"\"\"\nreturn self._end_node\n@end_node.setter\ndef end_node(self, node: Node):\nif self._end_node:\nself._end_node.relations.remove(self)\nnode.relations.append(self)\nself._end_node = node\ndef __str__(self):\nreturn f\"{self.start_node}-[{self.relation_type}]-&gt;{self.end_node}\"\n</code></pre>"},{"location":"api/api_relation/#dict2graph.relation.Relation.end_node","title":"<code>end_node: Node</code>  <code>writable</code> <code>property</code>","text":"<p>The target node of the relationship</p> <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The end node as a Dict2Graph.Node instance</p>"},{"location":"api/api_relation/#dict2graph.relation.Relation.relation_type","title":"<code>relation_type: str</code>  <code>writable</code> <code>property</code>","text":"<p>The name of the relationship. As in Neo4j Relation Type</p> <p>Defaults to a string with following structure:</p> <p><code>&lt;start node first label&gt;_HAS_&lt;end_node_first_label&gt;</code></p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The relationship type as str</p>"},{"location":"api/api_relation/#dict2graph.relation.Relation.start_node","title":"<code>start_node: Node</code>  <code>writable</code> <code>property</code>","text":"<p>The node from which the relationship is originating</p> <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The start node as a Dict2Graph.Node instance</p>"},{"location":"api/api_relation/#dict2graph.relation.Relation.__init__","title":"<code>__init__(start_node, end_node, relation_type=None, **kwargs)</code>","text":"<p>Create a new relationship</p> <p>Parameters:</p> Name Type Description Default <code>start_node</code> <code>Node</code> <p>The node from which the relationship will start</p> required <code>end_node</code> <code>Node</code> <p>The node to which the relationship will go to</p> required <code>relation_type</code> <code>str</code> <p>The name if the relation. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any further properties of this relationship. Defaults to None.</p> <code>{}</code> Source code in <code>dict2graph/relation.py</code> <pre><code>def __init__(\nself, start_node: Node, end_node: Node, relation_type: str = None, **kwargs\n):\n\"\"\"Create a new relationship\n    Args:\n        start_node (Node): The node from which the relationship will start\n        end_node (Node): The node to which the relationship will go to\n        relation_type (str, optional): The name if the relation. Defaults to None.\n        **kwargs (Any, optional): Any further properties of this relationship. Defaults to None.\n    \"\"\"\nself._relation_type = relation_type\nself._start_node = None\nself._end_node = None\nself.start_node = start_node\nself.end_node = end_node\nself._origin_relation_type: str = relation_type\nself.deleted = False\nself.update(**kwargs)\n</code></pre>"},{"location":"api/api_transformer/","title":"Transformer","text":""},{"location":"api/api_transformer/#dict2graph.Transformer","title":"<code>dict2graph.Transformer</code>","text":"Source code in <code>dict2graph/transformers/_base.py</code> <pre><code>class Transformer:\nclass NodeTransformerMatcher:\ndef _set_node_matcher(\nself,\nlabel_match: Union[str, List[str], AnyLabel],\nhas_one_label_of: List[str] = None,\nhas_none_label_of: List[str] = None,\n):\nif isinstance(label_match, str):\nlabel_match = [label_match]\nself.label_match: Union[List[str], AnyLabel] = label_match\nself.has_one_label_of = has_one_label_of\nself.has_none_label_of = has_none_label_of\ndef _match(self, node: Node) -&gt; bool:\nif self.has_none_label_of is not None and not set(\nself.has_none_label_of\n).isdisjoint(node.labels):\nreturn False\nif self.has_one_label_of is not None and not set(\nself.has_one_label_of\n).isdisjoint(set(node.labels)):\nreturn True\nif self.label_match == AnyLabel or set(self.label_match).issubset(\nset(node.labels)\n):\nreturn True\nreturn False\ndef do(self, transform: _NodeTransformerBase) -&gt; _NodeTransformerBase:\ntransform._set_matcher(self)\nreturn transform\nclass RelTransformerMatcher:\ndef _set_rel_matcher(\nself,\nrelation_type_match: Union[str, List[str], AnyRelation],\nrelation_type_is_not_in: List[str],\n):\nif isinstance(relation_type_match, str):\nself.relation_type_match = [relation_type_match]\nelse:\nself.relation_type_match = relation_type_match\nself.relation_type_match = relation_type_match\nif relation_type_is_not_in:\nself.relation_type_is_not_in = relation_type_is_not_in\nelse:\nself.relation_type_is_not_in = []\ndef _match(self, rel: Relation) -&gt; bool:\nif (\nself.relation_type_match in [None, AnyRelation]\nor rel.relation_type in self.relation_type_match\n) and rel.relation_type not in self.relation_type_is_not_in:\nreturn True\nreturn False\ndef do(self, transform: _RelationTransformerBase) -&gt; _RelationTransformerBase:\ntransform._set_matcher(self)\nreturn transform\n@classmethod\ndef match_nodes(\ncls,\nhas_labels: Union[str, List[str], AnyLabel] = AnyLabel,\nhas_one_label_of: List[str] = None,\nhas_none_label_of: List[str] = None,\n) -&gt; NodeTransformerMatcher:\n\"\"\"Match nodes to apply tranformers\n        Args:\n            has_labels (Union[str, List[str], AnyLabel], optional): _description_. Defaults to AnyLabel.\n            has_one_label_of (List[str], optional): _description_. Defaults to None.\n            has_none_label_of (List[str], optional): _description_. Defaults to None.\n        Returns:\n            NodeTransformerMatcher: _description_\n        \"\"\"\ntm = Transformer.NodeTransformerMatcher()\ntm._set_node_matcher(\nlabel_match=has_labels,\nhas_one_label_of=has_one_label_of,\nhas_none_label_of=has_none_label_of,\n)\nreturn tm\n@classmethod\ndef match_rels(\ncls,\nrelation_type: Union[str, List[str], AnyRelation] = AnyRelation,\nrelation_type_is_not_in: List[str] = None,\n) -&gt; RelTransformerMatcher:\n\"\"\"Match relationships to apply tranformers\n        Args:\n            relation_name (Union[str, AnyRelation], optional): A relation type as string or mulitple relation types as list of string. Defaults to AnyRelation.\n        Returns:\n            RelTransformerMatcher: _description_\n        \"\"\"\ntm = Transformer.RelTransformerMatcher()\ntm._set_rel_matcher(\nrelation_type_match=relation_type,\nrelation_type_is_not_in=relation_type_is_not_in,\n)\nreturn tm\n</code></pre>"},{"location":"api/api_transformer/#dict2graph.transformers._base.Transformer.match_nodes","title":"<code>match_nodes(has_labels=AnyLabel, has_one_label_of=None, has_none_label_of=None)</code>  <code>classmethod</code>","text":"<p>Match nodes to apply tranformers</p> <p>Parameters:</p> Name Type Description Default <code>has_labels</code> <code>Union[str, List[str], AnyLabel]</code> <p>description. Defaults to AnyLabel.</p> <code>AnyLabel</code> <code>has_one_label_of</code> <code>List[str]</code> <p>description. Defaults to None.</p> <code>None</code> <code>has_none_label_of</code> <code>List[str]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NodeTransformerMatcher</code> <code>NodeTransformerMatcher</code> <p>description</p> Source code in <code>dict2graph/transformers/_base.py</code> <pre><code>@classmethod\ndef match_nodes(\ncls,\nhas_labels: Union[str, List[str], AnyLabel] = AnyLabel,\nhas_one_label_of: List[str] = None,\nhas_none_label_of: List[str] = None,\n) -&gt; NodeTransformerMatcher:\n\"\"\"Match nodes to apply tranformers\n    Args:\n        has_labels (Union[str, List[str], AnyLabel], optional): _description_. Defaults to AnyLabel.\n        has_one_label_of (List[str], optional): _description_. Defaults to None.\n        has_none_label_of (List[str], optional): _description_. Defaults to None.\n    Returns:\n        NodeTransformerMatcher: _description_\n    \"\"\"\ntm = Transformer.NodeTransformerMatcher()\ntm._set_node_matcher(\nlabel_match=has_labels,\nhas_one_label_of=has_one_label_of,\nhas_none_label_of=has_none_label_of,\n)\nreturn tm\n</code></pre>"},{"location":"api/api_transformer/#dict2graph.transformers._base.Transformer.match_rels","title":"<code>match_rels(relation_type=AnyRelation, relation_type_is_not_in=None)</code>  <code>classmethod</code>","text":"<p>Match relationships to apply tranformers</p> <p>Parameters:</p> Name Type Description Default <code>relation_name</code> <code>Union[str, AnyRelation]</code> <p>A relation type as string or mulitple relation types as list of string. Defaults to AnyRelation.</p> required <p>Returns:</p> Name Type Description <code>RelTransformerMatcher</code> <code>RelTransformerMatcher</code> <p>description</p> Source code in <code>dict2graph/transformers/_base.py</code> <pre><code>@classmethod\ndef match_rels(\ncls,\nrelation_type: Union[str, List[str], AnyRelation] = AnyRelation,\nrelation_type_is_not_in: List[str] = None,\n) -&gt; RelTransformerMatcher:\n\"\"\"Match relationships to apply tranformers\n    Args:\n        relation_name (Union[str, AnyRelation], optional): A relation type as string or mulitple relation types as list of string. Defaults to AnyRelation.\n    Returns:\n        RelTransformerMatcher: _description_\n    \"\"\"\ntm = Transformer.RelTransformerMatcher()\ntm._set_rel_matcher(\nrelation_type_match=relation_type,\nrelation_type_is_not_in=relation_type_is_not_in,\n)\nreturn tm\n</code></pre>"}]}